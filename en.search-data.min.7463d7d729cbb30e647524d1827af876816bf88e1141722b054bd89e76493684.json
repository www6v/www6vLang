[{"id":0,"href":"/Lang/docs/Java/","title":"Java","section":"Lang","content":"test\n"},{"id":1,"href":"/Lang/docs/Java/core/","title":"Java","section":"Java","content":"test\n"},{"id":2,"href":"/Lang/docs/Java/concurrent/threadNum/","title":"线程池最佳线程数","section":"并发","content":"\n{% asset_img threadNum.jpg 线程池最佳线程数 %}\n最佳实践: 曾经遇到过任务被丢给线程池之后，长时间都没有被执行的诡异问题。最初，我认为这是代码的 Bug 导致的，后来经过排查发现，是因为线程池的coreThreadCount 和 maxThreadCount 设置的比较小，导致任务在线程池里面大量的堆积，在调大了这两个参数之后问题就解决了.\n参考: # 工作线程数究竟要设置为多少 架构师之路 蚂蚁金服技术专家总结：性能优化的常见招式 jurassic_1 《Java 并发编程实践》 8.2定制线程池的大小 Brian Goetz 高并发系统设计40问 - 07 | 池化技术：如何减少频繁创建数据库连接的性能损耗？ 唐扬 "},{"id":3,"href":"/Lang/docs/Java/concurrent/volatile-CAS/","title":"多线程中的volatile和CAS","section":"并发","content":"\n{% asset_img volatile-CAS.jpg 多线程中的volatile和CAS %}\n参考: # Java 理论与实践: 正确使用 Volatile 变量 从volatile解读ConcurrentHashMap（jdk1.6.0）无锁读 为什么volatile不能保证原子性而Atomic可以 阿里巴巴Java开发手册 非阻塞同步算法与CAS(Compare and Swap)无锁算法 非阻塞算法在并发容器中的实现 程晓明 "},{"id":4,"href":"/Lang/docs/Java/concurrent/lock/","title":"多线程中的锁","section":"并发","content":"\n{% asset_img Lock-theory.jpg %}\n{% asset_img Lock-java.jpg %}\n参考 # 《java并发编程实践》 13章 显示锁 ,13.5 读-写锁 轻松学习java可重入锁(ReentrantLock)的实现原理 锁模式 -\u0026gt; 共享锁，排他锁 轻松掌握java读写锁(ReentrantReadWriteLock)的实现原理 Java中的读/写锁 作者:Jakob Jenkov Java同步块 作者:Jakob Jenkov 《Java并发编程的艺术》-Java并发包中的读写锁及其实现分析 怎么理解Condition 码梦为生|刘锟洋 多线程之：偏向锁，轻量级锁，重量级锁 无信不立 "},{"id":5,"href":"/Lang/docs/Java/concurrent/thread/","title":"Java多线程总结","section":"并发","content":"\n{% asset_img thread.jpg Java多线程总结 %}\n参考： # 非阻塞同步算法与CAS(Compare and Swap)无锁算法 高性能队列——Disruptor java多线程体系 东隼 《并发编程实践》 Brian Goetz 第3章 Java并发之AQS详解 waterystone 面试官：线程顺序执行,这么多答案你都答不上来？ Join, wait, Condition, 线程池 "},{"id":6,"href":"/Lang/docs/Java/concurrent/cancelAndShutdown/cancelAndShutdown/","title":"Java多线程中的取消和关闭","section":"并发","content":"\n取消和关闭 基础 中断状态 中断请求 取消点 任务取消 取消策略（how/when/what） how/when volatile的取消状态+非阻塞方法(正确) volatile的取消状态+阻塞方法(错误) 中断的状态显示的检查（正确）.Thread.currentThread().isInterrupted() what, 中断策略（如何响应中断请求） InterruptedException传递给调用者，捕获后恢复中断的状态，Thread.currentThread().interrupted(). 封装成shutdown方法 通过Future.cancel来取消任务 中断当前线程 阻塞函数 抛出InterruptedException Thread.isInterrupted()返回false eg. Object的wait(),Thread的join(),sleep() IO上的阻塞 BIO Socket读写网络 JDBC驱动MySQL-connector-java nio InterruptibleChannel InterruptibleChannel将被关闭 抛出ClosedByInterruptException Thread.isInterrupted()返回true Selector Selector#select()方法将立即返回 不会抛出异常 Thread.isInterrupted()返回true 服务取消 生命周期方法 start() stop() ExceuteService.shutDown()/shutDownNow() 致命药丸(akka的Poison Pill) 锁中断 不可中断 内部锁synchronized, ReentrantLock.lock() 可中断 显示锁ReentrantLock.tryLock()，.lockInterruptibly() "},{"id":7,"href":"/Lang/docs/Java/core/javaMemoryLeak/javaMemoryLeak/","title":"Java内存泄漏的案例和解决方案","section":"Java","content":"\n如果一个可达对象的生命周期很长，它有一个生命周期较短的对象引用，此时就可能出现Java内存泄漏。也即是说， 造成内存泄漏的原因是对象虽然可达但不是活动的。\n避免内存泄漏的三种方式 # 1. 软引用 # 对于缓存，如果没有合适的策略让老的缓存项目到期就可能遇到内存泄漏。\n我们希望缓存能用上所有的可用内存，只是在需要额外资源的时候才释放资源。 通过软可达可以实现资源的释放。\n释放软可达对象的规则：\nI. gc抛出OOM异常之前要尝试释放软引用\nII. gc以LRU的顺序释放软引用\n举例：\nGoogle LoadingCache中的CacheBuilder.softValues()\n2. 弱引用 # 弱引用可以用于协助垃圾回收， 这是通用的解决方案。\n举例： threadLocal\n每个线程中有一个Map, 这个Map的类型是ThreadLocal.ThreadLocalMap. Map中的key为一个threadlocal实例. 这个Map的key使用了弱引用。 每个key都弱引用指向threadlocal. 当把threadlocal实例置为null以后,没有任何强引用指向threadlocal实例,所以threadlocal将会被gc回收.\nps: value却不能回收,因为存在一条从current thread连接过来的强引用. 只有当前thread结束以后, current thread就不会存在栈中,强引用断开, Current Thread, Map, value将全部被GC回收. 如果使用线程池，线程的强引用会长时间的存在，为了防止内存泄漏，最好的做法是将调用threadlocal的remove方法。\n3. 打开(增加)和关闭（删除）方法成对出现 # 资源申请和回收不成对会使资源没释放，造成内存泄漏。\n举例：\nI. 在finally块中关闭打开的资源和异常处理。\nII. 使用try-with-resources语句（Java SE7新特性）\ntry (BufferedReader br = new BufferedReader(new FileReader(path))) {\rreturn br.readLine();\r} 内存泄漏案例 # \u0026laquo;实战Java虚拟机——JVM故障诊断与性能优化\u0026raquo; 7.2.2节中有关JDK6.0里String.substring()可能引发的内存泄漏\n\u0026laquo; Effective.Java.中文版 - 第二版\u0026raquo; - 第六条 消除过期的对象引用 如果一个类自己管理内存，程序员就要警惕内存泄漏问题。\n大量static字段引起的内存泄漏\n不正确的equals()和hashCode()实现\n常量字符串造成的内存泄漏\n参考 # 1 . 了解Java中的内存泄漏 作者:baeldung 译者:thornhill\n"},{"id":8,"href":"/Lang/docs/Java/core/javaString/javaString/","title":"Java 字符串","section":"Java","content":"\n{% asset_img string.jpg 字符串 %}\n"},{"id":9,"href":"/Lang/docs/Java/core/javaMemoryModel/javaMemoryModel/","title":"Java内存模型","section":"Java","content":"\n{% asset_img memoryModel.jpg Java内存模型 %}\n参考: # JVM内部原理 原文作者：James D Bloom 翻译：梅小西 浅谈HotSpot逃逸分析 占小狼 class卸载、热替换和Tomcat的热部署的分析 heavensay java自定义classloader引发的思考 editice 《深入理解java虚拟机》 第二章 周志明 浅谈Java String内幕 占小狼 JMM和底层实现原理 王侦 *** 未 "},{"id":10,"href":"/Lang/docs/Java/concurrent/concurrentCollection/","title":"Java并发容器总结","section":"并发","content":"\n{% asset_img concurrentCollection.jpg Java并发容器总结 %}\n参考: # 关于Java集合的小抄 白衣 谈谈ConcurrentHashMap1.7和1.8的不同实现 占小狼 高性能队列——Disruptor 非阻塞算法在并发容器中的实现 程晓明 从volatile解读ConcurrentHashMap（jdk1.6.0）无锁读 绫萱 JAVA并发容器代码随读 BucketLi 聊聊并发（四）深入分析ConcurrentHashMap 方 腾飞 Java8 新特性之流式数据处理 深蓝至尊 不止JDK7的HashMap，JDK8的ConcurrentHashMap也会造成CPU 100% 朱小厮 朱忠华 "}]