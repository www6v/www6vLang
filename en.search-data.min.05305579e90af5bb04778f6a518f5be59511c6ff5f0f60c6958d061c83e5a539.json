[{"id":0,"href":"/Lang/docs/Java/","title":"Java","section":"Lang","content":"test\n"},{"id":1,"href":"/Lang/docs/Golang/","title":"Java","section":"Lang","content":"test\n"},{"id":2,"href":"/Lang/docs/Java/core/javaFeature/","title":"Java Feature","section":"Core","content":"\n版本 # 版本 发布日期 JDK 19 2022/09/20 JDK 20 2023/03/21 版本+特性 [1] # Java 1.4 # NIO（New I/O） Java 5（Java 1.5） # 泛型 自动装箱/拆箱 枚举类型 Java 7 # Try-with-resources Java SE 8（Java 8）- LTS长期支持版本 # Lambda 表达式：简化函数式编程。允许以更简洁的语法编写函数式接口的实例，使代码更加简洁。 Stream API：用于处理集合，支持函数式操作，如过滤、映射和聚合。 方法引用：允许直接引用现有方法或构造函数，避免了重复编写类似的代码。 接口的默认方法：在接口中提供默认实现，提高接口的灵活性。 时间 API：提供了一组强大的时间操作类，简化了日期和时间的操作。 重复注解：允许在同一个地方多次声明同一个注解，提高了代码的可读性。 CompletableFuture 类：简化异步编程，提供更好的错误处理和异常处理机制。 Nashorn 引擎：提供了一种基于 JavaScript 的解决方案，允许将 JavaScript 代码嵌入到 Java 应用程序中。 Optional 类：减少空指针异常，提高代码可读性。 Java SE 9（Java 9） # 模块系统（Project Jigsaw）：将 Java 的庞大代码库划分为可重用的模块，简化大型应用的构建和维护。 JShell：Java 的交互式命令行工具，用于快速尝试和测试 Java 代码片段。 新的集合工厂方法：方便地创建不可变集合，如 List.of()、Set.of() 和 Map.of()。 Java SE 10（Java 10） # 局部变量类型推断：使用 var 关键字自动推断局部变量的类型，简化代码。 垃圾收集器接口改进：提高了垃圾收集器的可插拔性和灵活性。 Java SE 11（Java 11）-LTS长期支持版本 # 新的 HTTP 客户端 API：支持 HTTP/2 和 WebSocket，提供了更现代化的编程方式。 改进的垃圾收集：引入了 ZGC 和 Epsilon 垃圾收集器。 String 类的新方法：如 lines()、isBlank()、strip() 等。 Java SE 12（Java 12） # switch 表达式：允许在 switch 语句中使用表达式，提高了代码的可读性和简洁性。 改进的字符串类：提供了一些新的方法，使得字符串的操作更加方便和高效。 Shenandoah 垃圾回收器：提供了一种低停顿时间的垃圾回收器，适用于大型堆内存的应用程序。 微基准测试套件：提供了一种用于快速测试性能的微基准测试框架。 JDK 源代码重构：对 JDK 源代码进行了重构，提高了代码的可读性和维护性。 Java SE 13 （Java 13） # 文本块：允许以更简洁的语法创建多行字符串，提高了代码的可读性和简洁性。 改进的 switch 表达式：允许在 switch 语句中使用表达式，提供更好的类型推断和更灵活的写法。 ZGC 垃圾回收器改进：提高了 ZGC 垃圾回收器的性能和可靠性。 应用程序类数据共享改进：提高了应用程序类数据共享的性能和效率。 Java SE 14 （Java 14） # 2020年3月17日\ninstanceof 模式匹配：允许在 instanceof 操作符中使用模式匹配，提高了代码的简洁性和可读性。 Records 类：提供了一种更简单和安全的数据类的定义方式。 Switch 表达式增强：允许使用箭头操作符(-\u0026gt;)作为 lambda 表达式的简写语法。 文本块增强：允许在文本块中使用嵌入式表达式，使得文本块更加灵活和强大。 改进的 NullPointerException 信息：提供更详细的 NullPointerException 信息。 Java SE 15 （Java 15） # 隐式的类文件：允许在 Java 源代码中定义多个类，而不需要单独的类文件。 改进的文本块：允许在文本块中使用转义字符和 Unicode 转义，提高了文本块的灵活性和可读性。 改进的 switch 表达式：允许在 switch 语句中使用多个匹配项，提供更灵活的写法。 Sealed 类和接口：允许控制哪些类或接口可以继承或实现该类或接口，提高了代码的安全性和可维护性。 其他改进：包括增强的 ZGC 垃圾回收器、改进的内存管理、新增的 Unix 域套接字 API 等。 Java SE 16 （Java 16） # 增强的文本块：允许在文本块中使用转义字符和嵌入式表达式。 移除了废弃的 ParallelScavenge 垃圾回收器。 改进的 ZGC 垃圾回收器：提高了性能和可靠性，增加了可配置参数。 Records 类的增强：允许在 records 类中添加静态方法和私有构造函数。 Vector API：提供了一种新的 API，用于高效地执行矢量化操作。 Java SE 17（Java 17）-LTS长期支持版本 # 嵌套枚举：允许在类和接口中定义嵌套枚举，提高了代码的可读性和简洁性。 改进的 switch 语句：允许在 switch 语句中使用 case 标签作为表达式，提供更灵活的写法。 预览性功能：包括模式匹配、嵌套枚举、记录类的序列化等新特性。 增强的垃圾回收器：提高了性能和可靠性，增加了可配置参数。 其他改进：包括新的内存管理和性能优化，增强的 JIT 编译器等。 Java SE 18（Java 18）[2] # 400：默认使用 UTF-8 408：简易 Web 服务器 413：Java API 文档中的代码片段 416：使用方法句柄重新实现核心反射 417：矢量 API 418：网络地址解析 SPI 419：外部函数和内存 API 420：switch 的模式匹配 421：废弃对象终止机制\nJava SE 19（Java 19） [3] # 405: Record Patterns (Preview) 422: Linux/RISC-V Port 424: Foreign Function \u0026amp; Memory API (Preview) 425: Virtual Threads (Preview) 426: Vector API (Fourth Incubator) 427: Pattern Matching for switch (Third Preview) 428: Structured Concurrency (Incubator)\nJava SE 20（Java 20） [4] # 429: Scoped Values (Incubator) 432: Record Patterns (Second Preview) 433: Pattern Matching for switch (Fourth Preview) 434: Foreign Function \u0026amp; Memory API (Second Preview) 436: Virtual Threads (Second Preview) 437: Structured Concurrency (Second Incubator) 438: Vector API (Fifth Incubator)\nJava SE 21（Java 21） [5] # 430: String Templates (Preview) 431: Sequenced Collections 439: Generational ZGC 440: Record Patterns 441: Pattern Matching for switch 442: Foreign Function \u0026amp; Memory API (Third Preview) 443: Unnamed Patterns and Variables (Preview) 444: Virtual Threads [6][7] 445: Unnamed Classes and Instance Main Methods (Preview) 446: Scoped Values (Preview) 448: Vector API (Sixth Incubator) 449: Deprecate the Windows 32-bit x86 Port for Removal 451: Prepare to Disallow the Dynamic Loading of Agents 452: Key Encapsulation Mechanism API 453: Structured Concurrency (Preview)\n特性 [8] # 文字块 text blocks | JDK 13-JDK 15 # String textBlock = \u0026#34;\u0026#34;\u0026#34; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;\u0026#34;Hello World!\u0026#34;\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026#34;\u0026#34;\u0026#34;; System.out.println( \u0026#34;Here is the text block:\\n\u0026#34; + textBlock); record 档案类 [不可变] | JDK14-JDK16 # public record Circle(double radius) implements Shape { @Override public double area() { return Math.PI * radius * radius; } } sealed classes 封闭类 [扩展性] | JDK 15-JDK 17 # public abstract sealed class Shape permits Circle, Square { public final String id; public Shape(String id) { this.id = id; } public abstract double area(); } 类型匹配 [切除臃肿的强制转换] | JDK 14-JDK 16 # if (shape instanceof Rectangle rect) { return (rect.length == rect.width); } switch 表达式 [简化多情景操作] | JDK 12-JDK 14 # int daysInMonth = switch (month) { case Calendar.JANUARY, Calendar.MARCH, Calendar.MAY, Calendar.JULY, Calendar.AUGUST, Calendar.OCTOBER, Calendar.DECEMBER -\u0026gt; 31; case Calendar.APRIL, Calendar.JUNE, Calendar.SEPTEMBER, Calendar.NOVEMBER -\u0026gt; 30; case Calendar.FEBRUARY -\u0026gt; { if (((year % 4 == 0) \u0026amp;\u0026amp; !(year % 100 == 0)) || (year % 400 == 0)) { yield 29; } else { yield 28; } } default -\u0026gt; throw new RuntimeException( \u0026#34;Calendar in JDK does not work\u0026#34;); }; switch匹配 [适配不同的类型] | JDK 17-21 # public static boolean isSquare(Shape shape) { return switch (shape) { case null, Shape.Circle c -\u0026gt; false; case Shape.Square s -\u0026gt; true; }; } 外部内存接口 | JDK18-? # ByteBuffer \u0026amp;\u0026amp; 零拷贝 使用堆外存储最常用的办法，就是使用 ByteBuffer 这个类来分配直接存储空间（direct buffer）。JVM 虚拟机会尽最大努力直接在直接存储空间上执行 IO 操作，避免数据在本 地和 JVM 之间的拷贝。 由于频繁的内存拷贝是性能的主要障碍之一。所以为了极致的性能，应用程序通常也会尽 量避免内存的拷贝。理想的状况下，一份数据只需要一份内存空间，这就是我们常说的零 拷贝。\n用 ByteBuffer 这个类来分配直接存储空间的方法\npublic static ByteBuffer allocateDirect(int capacity); 第一个缺陷是没有资源释放的接口。 第二个缺陷是存储空间尺寸的限制。\n外部内存接口\ntry (ResourceScope scope = ResourceScope.newConfinedScope()) { MemorySegment segment = MemorySegment.allocateNative(4, scope); for (int i = 0; i \u0026lt; 4; i++) { MemoryAccess.setByteAtOffset(segment, i, (byte)\u0026#39;A\u0026#39;); } } 外部函数接口[取代Java本地接口] | JDK 17-? # public class HelloWorld { public static void main(String[] args) throws Throwable { try (ResourceScope scope = ResourceScope.newConfinedScope()) { CLinker cLinker = CLinker.getInstance(); MemorySegment helloWorld = CLinker.toCString(\u0026#34;Hello, world!\\n\u0026#34;, scope); MethodHandle cPrintf = cLinker.downcallHandle( CLinker.systemLookup().lookup(\u0026#34;printf\u0026#34;).get(), MethodType.methodType(int.class, MemoryAddress.class), FunctionDescriptor.of(CLinker.C_INT, CLinker.C_POINTER)); cPrintf.invoke(helloWorld.address()); } } } GC # G1, ZGC, 分代式 ZGC\n参考 # Java各个版本发布时间和主要特性整理！ Java 历史大版本及其详细特性介绍: Java 18 的新特性 JDK 19 JDK 20 JDK 21 Java19 虚拟线程原理介绍及实现 *** Java虚拟线程：异步编程之死 《深入剖析 Java 新特性》 范学雷 02,03,04,05,06,07,08,09,12, 13 从Java 11升级到Java 17 V 未 "},{"id":3,"href":"/Lang/docs/Golang/golangMap/","title":"Golang内置类型-Map","section":"Java","content":"\n目录 # Map 内部实现 # {% asset_img golang-map.jpg Golang Map %}\nmap的内部结构 # hmap bucket topHash 快速定位key,以空间换时间 每个 bucket 的 tophash 区域其实是用来快速定位 key 位置的. 这是一种以空间换时间的思路。 key value Go 运行时采用了把 key 和 value 分开存储的方式，而不是采用一个 kv 接着一个 kv 的 kv 紧邻方式存储，这带来的其实是算法上的复杂性，但却减少了因内存对齐带来的内存浪费。 overflow bmap map的内部函数 [4] # mapassign 写 mapdelete 删 mapaccess 读 扩容 [2] # buckets \u0026amp;\u0026amp; oldbuckets 两种扩容方式 [渐进式扩容, 类似redis rehash] 因为 overflow bucket 过多导致的“扩容”，实际上运行时会新建一个和现有规模一样的 bucket 数组，然后在 assign 和 delete 时做排空和迁移。 因为当前数据数量超出 LoadFactor 指定水位而进行的扩容，那么运行时会建立一个两倍于现有规模的 bucket 数组，但真正的排空和迁移工作也是在 assign 和 delete 时逐步进行的。 扩容 [4] # 触发: mapassign 时机: load factor 过大 OR overflow bucket 过多 搬运过程: 渐进式\nmapassign elem cout \u0026gt; bucket*6.5 -\u0026gt; bigger size grow overflow too many \u0026ndash;\u0026gt; same size grow noverflow \u0026gt;=2^15 nvoerflow \u0026lt; 2^15 \u0026amp;\u0026amp; nvoerflow \u0026gt; bucket count map 解决 hash 冲突 [3] # 在 map 解决 hash /分桶 冲突问题时，实际上结合了拉链法和开放寻址法两种思路. 以 map 的插入写流程为例，进行思路阐述： （1）桶数组中的每个桶，严格意义上是一个单向桶链表，以桶为节点进行串联； （2）每个桶固定可以存放 8 个 key-value 对； （3）当 key 命中一个桶时，首先根据开放寻址法，在桶的 8 个位置中寻找空位进行插入； （4）倘若桶的 8 个位置都已被占满，则基于桶的溢出桶指针，找到下一个桶，重复第（3）步； （5）倘若遍历到链表尾部，仍未找到空位，则基于拉链法，在桶链表尾部续接新桶，并插入 key-value 对.\n缺陷 [4] # 已经扩容的map, 无法 缩容 保证并发安全时, 要手动读写锁，易出错 多核心下表现差 map的使用 # map的使用 # value没有任何的限制, key有严格的限制\n并发 # 不可以并发读写 可以并发读 参考 # Go面试题系列：Go map的底层实现原理 《16|复合数据类型：原始map类型的实现机制是这样的？》 TonyBai Golang map 实现原理 《09 神奇的内置数据结构》 V "},{"id":4,"href":"/Lang/docs/Golang/golangStudy/","title":"Golang 学习资源","section":"Java","content":"\nGolang # 基础\n极客时间 《Go 并发编程实战课》 鸟窝 *** 极客时间 《Go语言从入门到实战》 好像看过 *** 极客时间 《Go 语言核心 36 讲》 郝林 ** 《Effective Go》 Effective Go 英文 高效的 Go 编程 Effective Go 中文 golang 编程规范 - Effective Go 中文 中文 50 Shades of Go 50 Shades of Go: Traps, Gotchas, and Common Mistakes for New Golang Devs\nGolang 新手可能会踩的 50 个坑 项目\u0026amp;进阶\n极客时间 《Go 语言项目开发实战》 孔令飞@腾讯 *** 极客训练营 《go进阶训练营 第4期》 bili V 毛剑 *** gotalk\ntalkgo @github Mix 0voice/Introduction-to-Golang ***\nGo 源码分析 Go source code analysis(zh-cn) 曹大 滴滴 ***\nbook Go语言圣经中文版 Go语言圣经（中文版） Go语言高级编程(Advanced Go Programming)\nGolang 个人blog # Tony Bai golang大神 *** 鸟窝 Java， golang 微博架构师 *** 罗道文 golang python NSQ 有深度 * 2017 停更 张晓龙 golang * 学习路线 # 学习路线 【上集】2022 年 Go 语言最全学习路线：十分钟带你过思维导图！ 【下集】2022 年 Go 语言最全学习路线：十分钟带你过思维导图！爆肝几天几夜整理的超详细 Go 学习 作者blog GOLANG ROADMAP *** GOLANG ROADMAP\n邀请码：caspar "},{"id":5,"href":"/Lang/docs/Golang/golangSlice/","title":"Golang基础-Slice","section":"Java","content":"\narray和slice # 数组长度是固定的， slice长度是可变的 slice底层实现 [2] # type slice struct { array unsafe.Pointer len int cap int } slice 初始化 [1] # 对于 make 来说，它可以初始化 slice 的 length 和 capacity，如果我们能确定 slice 里面会存放多少元素，从性能的角度考虑最好使用 make 初始化好，因为对于一个空的 slice append 元素进去每次达到阈值都需要进行扩容\nCode Example [1] # 参考 # [长文]从《100 Go Mistakes》我总结了什么？ gExamples slice_test.go 1.Go slice的底层实现原理? "},{"id":6,"href":"/Lang/docs/Golang/golangMemoryModel/","title":"Golang Rumtime-内存模型","section":"Java","content":"\n目录 # 系统内存管理[4] # 三个角色\nMutator [App] Allocator Bump/Sequential Allocator Free List Allocator First-Fit Next-Fit Best-Fit Segregated-Fit 工业界用的多, golang是这种类型的变种 Collector #2 栈内存管理\nmalloc \u0026lsquo;\u0026lt;128KB\u0026rsquo;\nprogram break \u0026lsquo;\u0026gt;=128KB\u0026rsquo; mmap Golang内存 # 内存分配 [4][5] # 三种类型 Tiny Small Large google tcmalloc 每个线程维护一个独立的内存池 多级别管理 4K， 8K， 16K \u0026hellip; 回收内存 放回预先分配的大块内存中 内存管理组件 mspan 68个规格， [8个字节\u0026hellip;32K] 双向链表 mcache 线程缓存 alloc tiny tinyoffset mcentral 管理全局的mspan供所有线程使用 noneempty mspan empty mspan mheap 管理动态分配内存, 持有的整个堆空间 arenas central 多级结构 mcache -\u0026gt; mcentral -\u0026gt; mheap 内存逃逸 [6] # 编译器会根据变量是否被外部引用来决定是否逃逸： 如果函数外部没有引用，则优先放到栈中； 如果函数外部存在引用，则必定放到堆中; 如果栈上放不下，则必定放到堆上; 内存泄漏 # 根因 [7][8]\ngoroutine泄漏 slice造成内存泄漏 原因 - 浅拷贝 time.Ticker造成内存泄漏 原因 - 没关闭timer cgo引起的内存泄漏 线程个数 常规分析手段 [8] 可以利用pprof对程序进行分析从而定位内存泄漏地址\n堆和栈 # 垃圾回收器 [9] #2 # Go语言的GC使用了**标记(mark)—清除(sweep)**技术\n系统结构 [1] # 现代计算机的多级存储结构 # cacheline 多核带来的问题 # 单变量的并发操作也必须用同步手段, 比如atomic 全局视角下观察到的多变量读写的顺序 可能会乱序 单变量 [2] # 单变量的原子读/写, 多核使用MESI协议保证正确性\n多变量 # 问题 乱序执行 内存重排\n解决方案 Memory barrier\nfalse sharing [3] # 因为CPU处理读写是以cache line为单位, 所以在并发修改变量时, 会一次性将其他CPU Core中的cache line invalidate 掉, 导致未修改的内存上相邻的变量也需要同步, 带来额外的性能负担\nHappen-before # 参考 # 《15 辅导 + 案例分析 + 答疑-更多课程》 体系课_Go高级工程师实战营(完结) *** MESI {% post_link \u0026lsquo;falseSharing\u0026rsquo; %} self 《13 Go 语言的内存管理与垃圾回收》 体系课_Go高级工程师实战营(完结) 1.Go 内存分配机制？ 2.Go 内存逃逸机制？ 浅谈Golang内存泄漏 code in git golang：快来抓住让我内存泄漏的“真凶”！ cgo引起的内存泄漏+常规分析手段 Go 垃圾回收器指南 {% post_link \u0026lsquo;javaMemoryModel\u0026rsquo; %} self "},{"id":7,"href":"/Lang/docs/Golang/golangGMP/","title":"Golang Rumtime-GMP","section":"Java","content":"\n目录 # Goroutine的调度 # Overview {% asset_img goroutine.JPG goroutine的调度 %} System Thread : kernel entity Processor : go实现的协程处理器 Goroutine : 协程 组件 # 组件 G: goroutine, 一个计算任务。 由需要执行的代码和其上下文组成, 上下文包括: 当前代码位置, 栈顶、 栈底地址，状态等。 M: machine, 系统线程, 执行实体, 想要在CPU上执行代码, 必须有线程 P: processor, 虚拟处理器, M必须获得P才能执行代码, 否则必须陷入休眠(后台监控线程除外).\n组件之间的关系 Processor在不同的系统线程里, 每个Processor挂载着一个协程队列，Processor依次调用Gorouine， 只有一个Gorouine是正在运行状态的。\nP 和 M 的个数问题 [1]\nP 的数量 在程序执行的任意时刻都只有 $GOMAXPROCS 个 goroutine 在同时运行 M 的数量 go 程序启动时，会设置 M 的最大数量，默认 10000 一个 M 阻塞了，会创建新的 M。 M 与 P 的数量没有绝对关系，一个 M 阻塞，P 就会去创建或者切换另一个 M，所以，即使 P 的默认数量是 1，也有可能会创建很多个 M 出来。\nP 和 M 何时会被创建 [1]\nP 何时创建 在确定了 P 的最大数量 n 后，运行时系统会根据这个数量创建 n 个 P。 M 何时创建 没有足够的 M 来关联 P 并运行其中的可运行的 G。 比如所有的 M 此时都阻塞住了，而 P 中还有很多就绪任务，就会去寻找空闲的 M，而没有空闲的，就会去创建新的 M 看参考文档里的图 {% asset_img GMP.jpg GMP %}\n协程跟线程是有区别的，线程由 CPU 调度是抢占式的，协程由用户态调度是协作式的，一个协程让出 CPU 后，才执行下一个协程。\n场景 # 处理阻塞[能被runtime拦截到的阻塞-非阻塞] [2]\n在线程发生阻塞的时候，不会无限制的创建线程 以下这些情况, 会把goroutine挂起，让g先进某个数据结构，待ready后再继续执行 不会占用线程， 线程会进入schedule，继续消费队列，执行其他的g {% asset_img \u0026lsquo;feizusai.jpg\u0026rsquo; %} 处理阻塞[不能被runtime拦截到的阻塞-阻塞] [2]\n两种情况 CGO 阻塞在syscall上时, 必须占用一个线程 sysmon, 在专有线程中执行, 不需要绑定P就可以执行 checkdead 常见误解 这个可以检查死锁 netpoll inject g list to global runqueue retake 如果syscall卡了很久，就把p剥离(handoffp) #1 如果用户g运行了很久, 就发信号SIGURG抢占 case\ncase1 一个协程运行时间运行的特别长。 守护线程计数， 如果processor完成的goroutine数量一直不变。在这个协程的任务栈里插入一个中断的标记，读到这个中断标记后，goroutine会把自己中断下来插入到等待队列的队尾。 case2 某个协程被io中断后， Processer会把自己移动到另一个可用的系统线程当中， 执行队列里的任务。 当这个协程io中断被唤醒后，会把自己加入到某个Processor的队列里， 或者加入到全局的等待队列里。 调度器的设计策略 [1]\nwork stealing 机制 hand off 机制 #1 生产端 [2] # {% asset_img \u0026lsquo;producer.JPG\u0026rsquo; %}\n消费端 [2] # {% asset_img \u0026lsquo;consumer.JPG\u0026rsquo; %}\n参考 # Golang的GMP原理与调度 *** 《04 Go 程序是怎么跑起来的》 *** #64 深入浅出 Golang Runtime 【 Go 夜读 】 goroutine , go network , gc *** 未 Golang深入理解GPM模型 *** 未 "},{"id":8,"href":"/Lang/docs/Java/other/designPatternsInJava/","title":"Java里的设计模式","section":"Other","content":"\n参考 # JDK里的设计模式 Examples of GoF Design Patterns in Java\u0026rsquo;s core libraries Java 设计模式 未 图说设计模式 未 常用开源框架中设计模式使用分析（全） 阿里加多 *** 未 设计模式概览图 *** 未 "},{"id":9,"href":"/Lang/docs/Java/other/optimize/","title":"JVM性能调优","section":"Other","content":"\n参考 # 从实际案例聊聊Java应用的GC优化 录录\n"},{"id":10,"href":"/Lang/docs/Java/core/collection/","title":"Java集合总结","section":"Core","content":"\n参考： # JDK Collection 源代码 关于Java集合的小抄 白衣 限流系统如何发现系统的热点 阿里中间件团队博客 不正当使用HashMap导致cpu 100%的问题追究 王宏江 并发环境下HashMap引起的full gc排查 ol_beta 不止JDK7的HashMap，JDK8的ConcurrentHashMap也会造成CPU 100% 朱小厮 朱忠华 "},{"id":11,"href":"/Lang/docs/Java/core/aop/","title":"AOP总结","section":"Core","content":"\n参考: # 1.AOP技术讨论 乒乓狂魔 2.AOP 那点事儿 黄勇 3.AOP 那点事儿（续集） 黄勇 4.AOP实现机制 fantasy 5.动态代理方案性能对比 javatar 6.Java动态代理机制详解（JDK 和CGLIB，Javassist，ASM） 亦山 7.Spring事务处理时自我调用的解决方案及一些实现方式的风险 张开涛\n"},{"id":12,"href":"/Lang/docs/Java/core/classloaderSummarize/","title":"Classloader总结","section":"Core","content":"\n参考: # 深入浅出ClassLoader 你真的了解ClassLoader吗？ 魏 鹏 class卸载、热替换和Tomcat的热部署的分析 heavensay 《实战Java虚拟机》 第10章 "},{"id":13,"href":"/Lang/docs/Java/core/gc/","title":"垃圾收集GC总结","section":"Core","content":"\n并发标记算法 # CMS： 三色标记算法 + 增量更新（Incremental update） G1： 三色标记算法 + STAB（snapshot-at-the-beginning） Java虚拟机 \u0026mdash;-三色标记与G1垃圾回收器 参考： # 源码分析：Java对象的内存分配 iceAeterna 《深入理解Java虚拟机（第2版）》 第3章 周志明 深入理解GC ——MinorGC\\MajorGC\\FullGC 张硕的博客 触发JVM进行Full GC的情况及应对策略 yexx Netty之有效规避内存泄漏 江南白衣 周期性Full GC的异常排查 weiplex 一个大对象引起的血案，GC的踩坑实录 何锦彬 生产环境下持久带满导致FullGC，如何跟踪 又是一个程序员粗心的代码引起频繁FullGC的案例 微信公众号里的 JVM初探- 使用堆外内存减少Full GC 菜鸟-翡青 我遇到tomcat 7 full gc频繁的问题 auzll 一次堆外OOM问题的排查过程 谢照东 占小狼的博客 美团三面：一个线程OOM，进程里其他线程还能运行么？ 孤独烟 Java技术驿站 netty 堆外内存泄露排查盛宴 闪电侠的博客 netty的bug 线上故障排查(2) - Java应用故障之堆溢出OOM问题及排查方案 冯立彬 未 "},{"id":14,"href":"/Lang/docs/Java/concurrent/threadNum/","title":"线程池最佳线程数","section":"并发","content":"\n最佳实践: 曾经遇到过任务被丢给线程池之后，长时间都没有被执行的诡异问题。最初，我认为这是代码的 Bug 导致的，后来经过排查发现，是因为线程池的coreThreadCount 和 maxThreadCount 设置的比较小，导致任务在线程池里面大量的堆积，在调大了这两个参数之后问题就解决了.\n参考: # 工作线程数究竟要设置为多少 架构师之路 蚂蚁金服技术专家总结：性能优化的常见招式 jurassic_1 《Java 并发编程实践》 8.2定制线程池的大小 Brian Goetz 高并发系统设计40问 - 07 | 池化技术：如何减少频繁创建数据库连接的性能损耗？ 唐扬 ​\n"},{"id":15,"href":"/Lang/docs/Java/concurrent/volatile-CAS/","title":"多线程中的volatile和CAS","section":"并发","content":"\n参考: # Java 理论与实践: 正确使用 Volatile 变量 从volatile解读ConcurrentHashMap（jdk1.6.0）无锁读 为什么volatile不能保证原子性而Atomic可以 阿里巴巴Java开发手册 非阻塞同步算法与CAS(Compare and Swap)无锁算法 非阻塞算法在并发容器中的实现 程晓明 "},{"id":16,"href":"/Lang/docs/Java/concurrent/lock/","title":"多线程中的锁","section":"并发","content":"\n参考 # 《java并发编程实践》 13章 显示锁 ,13.5 读-写锁 轻松学习java可重入锁(ReentrantLock)的实现原理 锁模式 -\u0026gt; 共享锁，排他锁 轻松掌握java读写锁(ReentrantReadWriteLock)的实现原理 Java中的读/写锁 作者:Jakob Jenkov Java同步块 作者:Jakob Jenkov 《Java并发编程的艺术》-Java并发包中的读写锁及其实现分析 怎么理解Condition 码梦为生|刘锟洋 多线程之：偏向锁，轻量级锁，重量级锁 无信不立 "},{"id":17,"href":"/Lang/docs/Java/concurrent/thread/","title":"Java多线程总结","section":"并发","content":"\n参考： # 非阻塞同步算法与CAS(Compare and Swap)无锁算法 高性能队列——Disruptor java多线程体系 东隼 《并发编程实践》 Brian Goetz 第3章 Java并发之AQS详解 waterystone 面试官：线程顺序执行,这么多答案你都答不上来？ Join, wait, Condition, 线程池 "},{"id":18,"href":"/Lang/docs/Java/concurrent/cancelAndShutdown/","title":"Java多线程中的取消和关闭","section":"并发","content":"\n取消和关闭 基础 中断状态 中断请求 取消点 任务取消 取消策略（how/when/what） how/when volatile的取消状态+非阻塞方法(正确) volatile的取消状态+阻塞方法(错误) 中断的状态显示的检查（正确）.Thread.currentThread().isInterrupted() what, 中断策略（如何响应中断请求） InterruptedException传递给调用者，捕获后恢复中断的状态，Thread.currentThread().interrupted(). 封装成shutdown方法 通过Future.cancel来取消任务 中断当前线程 阻塞函数 抛出InterruptedException Thread.isInterrupted()返回false eg. Object的wait(),Thread的join(),sleep() IO上的阻塞 BIO Socket读写网络 JDBC驱动MySQL-connector-java nio InterruptibleChannel InterruptibleChannel将被关闭 抛出ClosedByInterruptException Thread.isInterrupted()返回true Selector Selector#select()方法将立即返回 不会抛出异常 Thread.isInterrupted()返回true 服务取消 生命周期方法 start() stop() ExceuteService.shutDown()/shutDownNow() 致命药丸(akka的Poison Pill) 锁中断 不可中断 内部锁synchronized, ReentrantLock.lock() 可中断 显示锁ReentrantLock.tryLock()，.lockInterruptibly() "},{"id":19,"href":"/Lang/docs/Java/core/javaMemoryLeak/","title":"Java内存泄漏的案例和解决方案","section":"Core","content":"\n如果一个可达对象的生命周期很长，它有一个生命周期较短的对象引用，此时就可能出现Java内存泄漏。也即是说， 造成内存泄漏的原因是对象虽然可达但不是活动的。\n避免内存泄漏的三种方式 # 1. 软引用 # 对于缓存，如果没有合适的策略让老的缓存项目到期就可能遇到内存泄漏。\n我们希望缓存能用上所有的可用内存，只是在需要额外资源的时候才释放资源。 通过软可达可以实现资源的释放。\n释放软可达对象的规则：\nI. gc抛出OOM异常之前要尝试释放软引用\nII. gc以LRU的顺序释放软引用\n举例：\nGoogle LoadingCache中的CacheBuilder.softValues()\n2. 弱引用 # 弱引用可以用于协助垃圾回收， 这是通用的解决方案。\n举例： threadLocal\n每个线程中有一个Map, 这个Map的类型是ThreadLocal.ThreadLocalMap. Map中的key为一个threadlocal实例. 这个Map的key使用了弱引用。 每个key都弱引用指向threadlocal. 当把threadlocal实例置为null以后,没有任何强引用指向threadlocal实例,所以threadlocal将会被gc回收.\nps: value却不能回收,因为存在一条从current thread连接过来的强引用. 只有当前thread结束以后, current thread就不会存在栈中,强引用断开, Current Thread, Map, value将全部被GC回收. 如果使用线程池，线程的强引用会长时间的存在，为了防止内存泄漏，最好的做法是将调用threadlocal的remove方法。\n3. 打开(增加)和关闭（删除）方法成对出现 # 资源申请和回收不成对会使资源没释放，造成内存泄漏。\n举例：\nI. 在finally块中关闭打开的资源和异常处理。\nII. 使用try-with-resources语句（Java SE7新特性）\ntry (BufferedReader br = new BufferedReader(new FileReader(path))) {\rreturn br.readLine();\r} 内存泄漏案例 # \u0026laquo;实战Java虚拟机——JVM故障诊断与性能优化\u0026raquo; 7.2.2节中有关JDK6.0里String.substring()可能引发的内存泄漏\n\u0026laquo; Effective.Java.中文版 - 第二版\u0026raquo; - 第六条 消除过期的对象引用 如果一个类自己管理内存，程序员就要警惕内存泄漏问题。\n大量static字段引起的内存泄漏\n不正确的equals()和hashCode()实现\n常量字符串造成的内存泄漏\n参考 # 1 . 了解Java中的内存泄漏 作者:baeldung 译者:thornhill\n"},{"id":20,"href":"/Lang/docs/Java/core/javaString/","title":"Java 字符串","section":"Core","content":"\n"},{"id":21,"href":"/Lang/docs/Java/core/javaMemoryModel/","title":"Java内存模型","section":"Core","content":"\n参考: # JVM内部原理 原文作者：James D Bloom 翻译：梅小西 浅谈HotSpot逃逸分析 占小狼 class卸载、热替换和Tomcat的热部署的分析 heavensay java自定义classloader引发的思考 editice 《深入理解java虚拟机》 第二章 周志明 浅谈Java String内幕 占小狼 JMM和底层实现原理 王侦 *** 未 "},{"id":22,"href":"/Lang/docs/Java/concurrent/concurrentCollection/","title":"Java并发容器总结","section":"并发","content":"\n参考: # 关于Java集合的小抄 白衣 谈谈ConcurrentHashMap1.7和1.8的不同实现 占小狼 高性能队列——Disruptor 非阻塞算法在并发容器中的实现 程晓明 从volatile解读ConcurrentHashMap（jdk1.6.0）无锁读 绫萱 JAVA并发容器代码随读 BucketLi 聊聊并发（四）深入分析ConcurrentHashMap 方 腾飞 Java8 新特性之流式数据处理 深蓝至尊 不止JDK7的HashMap，JDK8的ConcurrentHashMap也会造成CPU 100% 朱小厮 朱忠华 "}]