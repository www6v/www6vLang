[{"id":0,"href":"/www6vLang/docs/Algo/algorithmSubjectCore/","title":"算法和数据结构[核心思路+资源]","section":"Algo","content":"\n核心思路[1] # 分治 回溯 贪心 技巧 # 双指针 BFS, DFS 参考 # 《Hello 算法》 ***\nhttps://www.hello-algo.com/\nhttps://github.com/krahets/hello-algo 1xx. 《labuladong 的算法笔记》 ***\nhttps://github.com/www6v/algorithm star 100K https://labuladong.github.io/algo/ labuladong 的算法网站\n1xx. https://github.com/wangzheng0822/algo 王争\n1xx. https://github.com/www6v/leetcode-2 作者出版了算法书\n1xx. https://github.com/stars/www6v/lists/it-algorithms\n动态规划（基础版）\nLeetCode 热题 100\n面试经典 150 题\n"},{"id":1,"href":"/www6vLang/docs/Algo/algorithm/","title":"算法和数据结构","section":"Algo","content":"\n一. Master Thereom 主定律 # 图1.主定律在常用算法中的应用\n二. 数据结构操作 O(n) # 图2.数据结构操作\n线性表: # Array, Stack, Queue, Singly-Linked List, Doubly-Linked List\rSkip List \u0026amp;\u0026amp; Binary Search Tree: # + Average \u0026amp;\u0026amp; Worst 相同\r+ Redis的SortedSet用Skip List实现\r二叉搜索树: # + 左子树上所有结点的值均小于它的根结点的值； 右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉搜索树。\r+ 最差时间复杂度的二叉搜索树是O(n)，退化成链表;\r所以提出了平衡二叉搜索树， 最差时间复杂度是O(logn)。\r平衡二叉搜索树: Red-Black Tree, Splay Tree, AVL Tree\rB-tree: # 多路搜索树，并不是二叉的\r三. 数组排序算法 O(n) # 稳定排序:有两个排序关键字的时候，稳定排序可以让第一个关键字排序的结果服务于第二个关键字排序中数值相等的那些数. [5][7]\n四 = 二 + 三 # 图4.BigO总结\n五. 堆实现 O(n) # 图5.堆实现\n堆实现: # Binary， Binomial， Fibonacci， Strict Fibonacci（性能好，用的比较多）\n参考: # 算法大牛的git 每个程序员都应该收藏的算法复杂度速查表 good 从头到尾彻底解析Hash表算法 big O good 董的博客 - 算法之排序算法 稳定排序，原地排序 Data Structure Visualizations good 五分钟小知识：为什么要分稳定排序和非稳定排序？ "},{"id":2,"href":"/www6vLang/docs/Algo/algorithmSubjectLinear/","title":"算法和数据结构[题目 线性表]","section":"Algo","content":"\n线性表[数组] # Top K问题 : 数组中最小的 k 个数 # 方法一： 堆， 时间复杂度 O(n log k) 方法二： 快排变形， （平均）时间复杂度 O(n)\n数组中最小的 k 个数：Top K 问题的两种经典解法\nLeetCode 88 # 题目\n合并有序数组 [简单]\nSolution\nLeetCode 88\n方法一：直接合并后排序 方法二：双指针 方法三：逆向双指针 Leetcode 283. # 题目\n移动零 LeetCode 540 # 题目\n数组的两分搜索\nSolution\nLeetCode 540. Single Element in a Sorted Array [中等]\n线性表[链表] # Leetcode 2 # 题目 两数相加 : 合并两个链表中的数，并返回一个新的链表\nSolution\nLeetcode 2.两数相加 Leetcode 2.两数相加\nLeetCode21 # 题目\n合并两个有序链表 [简单]\nSolution\npublic class ListNode {\rint val;\rListNode next;\rListNode(int x) { val = x; }\r}\rclass Solution {\rpublic ListNode mergeTwoLists(ListNode l1, ListNode l2) {\rListNode dummyHead = new ListNode(0);\rListNode lastNode = dummyHead;\rwhile (l1 != null \u0026amp;\u0026amp; l2 != null) {\rif (l1.val \u0026lt; l2.val) {\rlastNode.next = l1;\rl1 = l1.next;\r} else {\rlastNode.next = l2;\rl2 = l2.next;\r}\rlastNode = lastNode.next;\r}\rlastNode.next = l1 != null ? l1 : l2;\rreturn dummyHead.next;\r}\r} LeetCode题解21_合并两个有序链表 LeetCode21:合并两个有序链表\nLeetCode206 # 题目\n单链表的反转 [简单]\nSolution\n使用3个指针遍历单链表，逐个链接点进行反转。 复杂 从第2个节点到第N个节点，依次逐节点插入到第1个节点(head节点)之后，最后将第一个节点挪到新表的表尾。 容易理解 public static Node reverseList(Node node) {\rNode pre = null;\rNode next = null;\rwhile (node != null) {\rnext = node.next;\rnode.next = pre;\rpre = node;\rnode = next;\r}\rreturn pre;\r} 剑指 题16 理解单链表的反转(java实现) LeetCode206：反转链表\n快指针，慢指针 # 链表中环的检测\n硬解 每走一步，把节点的地址存在set中，走下一步的时候查找地址是否已经在set中 快指针是慢指针的两倍， 最后快指针和慢指针相遇 链表倒数第k个结点\n剑指 题15 题解： 快指针先于慢指针走若干步\n删除链表倒数第n个结点 [中等] LeetCode 19\n求链表的中间结点 -\u0026gt; 快指针是慢指针的两倍 LeetCode 例题精讲 | 05 双指针×链表问题：快慢指针\n在O(1)时间删除链表结点 # 剑指Offer\n最常规的做法是从链表的头结点开始，顺序遍历查找要删除的结点，并在链表中删除该结点。 这种思路由于需要顺序查找，时间复杂度自然就是O(n)。 然而，可以把下一个结点的内容复制到需要删除的结点上覆盖原有的内容，再把下一个结点删除， 就相当于把当前需要删除的结点删除了，这样的时间复杂度是O（1）。 线性表[栈,队列] # Leetcode 20 # 题目\n有效的括号[简单] Solution 题解：辅助栈 Leetcode 155 # 题目\n包含min函数的栈 [简单]\nSolution\n剑指 21题 , 指南 P1 题解：方法一：辅助栈 Leetcode 225 # 题目\n用队列实现栈\nSolution Leetcode 225. 用队列实现栈\nLeetcode 232 # 题目\n两个栈实现一个队列 [简单]\nSolution\n剑指 7题，指南 P5\n用数组来实现栈 # 用数组来实现栈\n参考 # 《剑指 offer》 《程序员代码面试指南》 数据结构与算法之美 - 07链表（下）：如何轻松写出正确的链表代码？ 王争 面试精选：链表问题集锦 *** 算法面试通关40讲 覃超\r06.面试题：反转一个单链表\u0026amp;判断链表是否有环 07.理论讲解：堆栈\u0026amp;队列 10.理论讲解：优先队列 "},{"id":3,"href":"/www6vLang/docs/Algo/algorithmSubjectBinary/","title":"算法和数据结构[题目 二叉树]","section":"Algo","content":"\n二叉树 # LeetCode 94 # 题目\n中序遍历 非递归算法\nSolution\n指南 P88 LeetCode 94：二叉树的中序遍历 在迭代的时候需要显式地将这个栈模拟出来\nLeetCode 102 # 题目 二叉树的层序遍历\nSolution\n[参考 19] LeetCode 102\nLeetCode102\n解1： BFS 队列辅助\n解2： DFS\nLeetCode 104 # 题目\n二叉树的最小/最大深度， 二叉树的深度\nSolution\n剑指 39题 ， 递归的方法\nLeetCode 104 BFS： 第一个达到的叶子节点是最小深度， 最后一个达到的叶子节点是最大深度。\nDFS递归。\nLeetCode 112 # 题目 二叉树中和为某一值的路径\nSolution\n剑指 25题 LeetCode 112: 路径总和. 用栈来存路径\nLeetCode 235,236 # 题目 公共祖先\nSolution\n剑指 50题 ，指南 P153\n[参考17] . 递归，非递归\n二叉树的最大距离（即相距最远的两个叶子节点）。 # 参考 # 《剑指 offer》 《程序员代码面试指南》 算法面试通关40讲 覃超\r19.面试题：二叉树\u0026amp;二叉搜索树的最近公共祖先 28.面试题：二叉树层次遍历 "},{"id":4,"href":"/www6vLang/docs/Algo/algorithmSubjectString/","title":"算法和数据结构[题目 字符串]","section":"Algo","content":"\n字符串 # Leetcode 3 # 题目\n一个字符串中， 要找到其中最长的字符串，并且没有重复字符。\nSolution\nLeetcode 3\nLeetCode 3\n3. 无重复字符的最长子串\nleetcode 8 # 题目\n字符串转换为整数\nSolution\n剑指 50题\nleetcode 8\nleetcode 8\nLeetcode 205. # 题目\n同构字符串 Leetcode 344. # 题目\n反转字符串\nSolution\n双指针\nLeetcode 415. # 题目\n字符串相加: 字符串表示的数字相加 Solution\nLeetcode 415. 字符串相加 字符串中第一个只出现一次的字符，如何优化算法使得遍历次数更少 # 剑指 35题\nKMP子串查找算法 # "},{"id":5,"href":"/www6vLang/docs/Algo/algorithmSubjectDynamicProgramming/","title":"算法和数据结构[题目 动态规划]","section":"Algo","content":"\n动态规划 # leetcode # 一维动态规划 # leetcode 53\n53. 最大子数组和 Solution\nSolution leetcode 70\n70. 爬楼梯 Solution\nSolution 多维动态规划 # leetcode 62 62.不同路径 Solution\nSolution 参考 # 背包问题研究与应用\n算法面试通关40讲 - 动态规划 覃超\n看一遍就理解：动态规划详解\n动态规划\n"},{"id":6,"href":"/www6vLang/docs/Algo/algorithmSubject/","title":"算法和数据结构[题目]","section":"Algo","content":"\nHashTable 哈希表 # 两数之和 # Leetcode 1 a + b = 9 a; b= 9 -a =\u0026gt; Set(查询) ; O(n)\n三数之和 # Leetcode 15 a, b -\u0026gt; 2 loop; c = -(a+b) -\u0026gt; Set(查询); O(n^2)\n堆 # 其他 # 最小响应时间的算法 # 有的task 执行时间长，有的task 执行时间短， 如何设计一个负载均衡策略\nQPS比Nginx提升60%，阿里Tengine负载均衡算法揭秘 超级负载均衡 来源于以前百度的blog [极客时间 - 程序员的数据基础课 19,20,21] 基于概率 响应时间短的概率越大， 响应时间是正态分布的 nginx fair负载均衡算法 按后端服务器的响应时间来分配请求，响应时间短的优先分配。 某一个id访问了系统多次，怎么做限流 # [参考12] : leecode 239 Array + sliding window maximum 解： + 优先级队列 大顶堆 O(n * logk) + queue deque O(n*1)\n递归模板 recursion # 求众数 # LeetCode第169号问题：求众数 LeetCode 169. Majority Element 剑指 29题， [参考18] 解1： map O(N) 解2：sort O（n logn） 解3: 摩尔投票法 特殊高效算法\nLRU cache # Leetcode 146. LRU 缓存 [参考20] 双向链表实现 Redis内存淘汰机制 allkeys-lru Cache replacement policies 简单LRU算法实现缓存\n布隆过滤器 # +有误判率 +难以删除 应用： Guava Bloomfilter Mapredue bloomfilter Google Guava之BloomFilter源码分析及基于Redis的重构\n如何在海量数据中判断某个数据是否存在 # 布隆过滤器\n面试题 16.26. 计算器 # Leetcode 面试题 16.26. 计算器 用Stack来实现\n参考 # 《剑指 offer》 《程序员代码面试指南》 LVS集群之十种调度算法及负载均衡——理论 算法面试通关40讲 覃超\r03.如何计算算法的复杂度 12.面试题：返回滑动窗口中的最大值 算法面试通关40讲 覃超\r23.面试题：求众数 55.理论讲解： LRU Cache LRU， LFU "},{"id":7,"href":"/www6vLang/docs/Java/core/javaFeature/","title":"Java Feature","section":"Core","content":"\n版本 # 版本 发布日期 JDK 19 2022/09/20 JDK 20 2023/03/21 版本+特性 [1] # Java 1.4 # NIO（New I/O） Java 5（Java 1.5） # 泛型 自动装箱/拆箱 枚举类型 Java 7 # Try-with-resources Java SE 8（Java 8）- LTS长期支持版本 # Lambda 表达式：简化函数式编程。允许以更简洁的语法编写函数式接口的实例，使代码更加简洁。 Stream API：用于处理集合，支持函数式操作，如过滤、映射和聚合。 方法引用：允许直接引用现有方法或构造函数，避免了重复编写类似的代码。 接口的默认方法：在接口中提供默认实现，提高接口的灵活性。 时间 API：提供了一组强大的时间操作类，简化了日期和时间的操作。 重复注解：允许在同一个地方多次声明同一个注解，提高了代码的可读性。 CompletableFuture 类：简化异步编程，提供更好的错误处理和异常处理机制。 Nashorn 引擎：提供了一种基于 JavaScript 的解决方案，允许将 JavaScript 代码嵌入到 Java 应用程序中。 Optional 类：减少空指针异常，提高代码可读性。 Java SE 9（Java 9） # 模块系统（Project Jigsaw）：将 Java 的庞大代码库划分为可重用的模块，简化大型应用的构建和维护。 JShell：Java 的交互式命令行工具，用于快速尝试和测试 Java 代码片段。 新的集合工厂方法：方便地创建不可变集合，如 List.of()、Set.of() 和 Map.of()。 Java SE 10（Java 10） # 局部变量类型推断：使用 var 关键字自动推断局部变量的类型，简化代码。 垃圾收集器接口改进：提高了垃圾收集器的可插拔性和灵活性。 Java SE 11（Java 11）-LTS长期支持版本 # 新的 HTTP 客户端 API：支持 HTTP/2 和 WebSocket，提供了更现代化的编程方式。 改进的垃圾收集：引入了 ZGC 和 Epsilon 垃圾收集器。 String 类的新方法：如 lines()、isBlank()、strip() 等。 Java SE 12（Java 12） # switch 表达式：允许在 switch 语句中使用表达式，提高了代码的可读性和简洁性。 改进的字符串类：提供了一些新的方法，使得字符串的操作更加方便和高效。 Shenandoah 垃圾回收器：提供了一种低停顿时间的垃圾回收器，适用于大型堆内存的应用程序。 微基准测试套件：提供了一种用于快速测试性能的微基准测试框架。 JDK 源代码重构：对 JDK 源代码进行了重构，提高了代码的可读性和维护性。 Java SE 13 （Java 13） # 文本块：允许以更简洁的语法创建多行字符串，提高了代码的可读性和简洁性。 改进的 switch 表达式：允许在 switch 语句中使用表达式，提供更好的类型推断和更灵活的写法。 ZGC 垃圾回收器改进：提高了 ZGC 垃圾回收器的性能和可靠性。 应用程序类数据共享改进：提高了应用程序类数据共享的性能和效率。 Java SE 14 （Java 14） # 2020年3月17日\ninstanceof 模式匹配：允许在 instanceof 操作符中使用模式匹配，提高了代码的简洁性和可读性。 Records 类：提供了一种更简单和安全的数据类的定义方式。 Switch 表达式增强：允许使用箭头操作符(-\u0026gt;)作为 lambda 表达式的简写语法。 文本块增强：允许在文本块中使用嵌入式表达式，使得文本块更加灵活和强大。 改进的 NullPointerException 信息：提供更详细的 NullPointerException 信息。 Java SE 15 （Java 15） # 隐式的类文件：允许在 Java 源代码中定义多个类，而不需要单独的类文件。 改进的文本块：允许在文本块中使用转义字符和 Unicode 转义，提高了文本块的灵活性和可读性。 改进的 switch 表达式：允许在 switch 语句中使用多个匹配项，提供更灵活的写法。 Sealed 类和接口：允许控制哪些类或接口可以继承或实现该类或接口，提高了代码的安全性和可维护性。 其他改进：包括增强的 ZGC 垃圾回收器、改进的内存管理、新增的 Unix 域套接字 API 等。 Java SE 16 （Java 16） # 增强的文本块：允许在文本块中使用转义字符和嵌入式表达式。 移除了废弃的 ParallelScavenge 垃圾回收器。 改进的 ZGC 垃圾回收器：提高了性能和可靠性，增加了可配置参数。 Records 类的增强：允许在 records 类中添加静态方法和私有构造函数。 Vector API：提供了一种新的 API，用于高效地执行矢量化操作。 Java SE 17（Java 17）-LTS长期支持版本 # 嵌套枚举：允许在类和接口中定义嵌套枚举，提高了代码的可读性和简洁性。 改进的 switch 语句：允许在 switch 语句中使用 case 标签作为表达式，提供更灵活的写法。 预览性功能：包括模式匹配、嵌套枚举、记录类的序列化等新特性。 增强的垃圾回收器：提高了性能和可靠性，增加了可配置参数。 其他改进：包括新的内存管理和性能优化，增强的 JIT 编译器等。 Java SE 18（Java 18）[2] # 400：默认使用 UTF-8 408：简易 Web 服务器 413：Java API 文档中的代码片段 416：使用方法句柄重新实现核心反射 417：矢量 API 418：网络地址解析 SPI 419：外部函数和内存 API 420：switch 的模式匹配 421：废弃对象终止机制\nJava SE 19（Java 19） [3] # 405: Record Patterns (Preview) 422: Linux/RISC-V Port 424: Foreign Function \u0026amp; Memory API (Preview) 425: Virtual Threads (Preview) 426: Vector API (Fourth Incubator) 427: Pattern Matching for switch (Third Preview) 428: Structured Concurrency (Incubator)\nJava SE 20（Java 20） [4] # 429: Scoped Values (Incubator) 432: Record Patterns (Second Preview) 433: Pattern Matching for switch (Fourth Preview) 434: Foreign Function \u0026amp; Memory API (Second Preview) 436: Virtual Threads (Second Preview) 437: Structured Concurrency (Second Incubator) 438: Vector API (Fifth Incubator)\nJava SE 21（Java 21） [5] # 430: String Templates (Preview) 431: Sequenced Collections 439: Generational ZGC 440: Record Patterns 441: Pattern Matching for switch 442: Foreign Function \u0026amp; Memory API (Third Preview) 443: Unnamed Patterns and Variables (Preview) 444: Virtual Threads [6][7] 445: Unnamed Classes and Instance Main Methods (Preview) 446: Scoped Values (Preview) 448: Vector API (Sixth Incubator) 449: Deprecate the Windows 32-bit x86 Port for Removal 451: Prepare to Disallow the Dynamic Loading of Agents 452: Key Encapsulation Mechanism API 453: Structured Concurrency (Preview)\n特性 [8] # 文字块 text blocks | JDK 13-JDK 15 # String textBlock = \u0026#34;\u0026#34;\u0026#34; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;\u0026#34;Hello World!\u0026#34;\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026#34;\u0026#34;\u0026#34;; System.out.println( \u0026#34;Here is the text block:\\n\u0026#34; + textBlock); record 档案类 [不可变] | JDK14-JDK16 # public record Circle(double radius) implements Shape { @Override public double area() { return Math.PI * radius * radius; } } sealed classes 封闭类 [扩展性] | JDK 15-JDK 17 # public abstract sealed class Shape permits Circle, Square { public final String id; public Shape(String id) { this.id = id; } public abstract double area(); } 类型匹配 [切除臃肿的强制转换] | JDK 14-JDK 16 # if (shape instanceof Rectangle rect) { return (rect.length == rect.width); } switch 表达式 [简化多情景操作] | JDK 12-JDK 14 # int daysInMonth = switch (month) { case Calendar.JANUARY, Calendar.MARCH, Calendar.MAY, Calendar.JULY, Calendar.AUGUST, Calendar.OCTOBER, Calendar.DECEMBER -\u0026gt; 31; case Calendar.APRIL, Calendar.JUNE, Calendar.SEPTEMBER, Calendar.NOVEMBER -\u0026gt; 30; case Calendar.FEBRUARY -\u0026gt; { if (((year % 4 == 0) \u0026amp;\u0026amp; !(year % 100 == 0)) || (year % 400 == 0)) { yield 29; } else { yield 28; } } default -\u0026gt; throw new RuntimeException( \u0026#34;Calendar in JDK does not work\u0026#34;); }; switch匹配 [适配不同的类型] | JDK 17-21 # public static boolean isSquare(Shape shape) { return switch (shape) { case null, Shape.Circle c -\u0026gt; false; case Shape.Square s -\u0026gt; true; }; } 外部内存接口 | JDK18-? # ByteBuffer \u0026amp;\u0026amp; 零拷贝 使用堆外存储最常用的办法，就是使用 ByteBuffer 这个类来分配直接存储空间（direct buffer）。JVM 虚拟机会尽最大努力直接在直接存储空间上执行 IO 操作，避免数据在本 地和 JVM 之间的拷贝。 由于频繁的内存拷贝是性能的主要障碍之一。所以为了极致的性能，应用程序通常也会尽 量避免内存的拷贝。理想的状况下，一份数据只需要一份内存空间，这就是我们常说的零 拷贝。\n用 ByteBuffer 这个类来分配直接存储空间的方法\npublic static ByteBuffer allocateDirect(int capacity); 第一个缺陷是没有资源释放的接口。 第二个缺陷是存储空间尺寸的限制。\n外部内存接口\ntry (ResourceScope scope = ResourceScope.newConfinedScope()) { MemorySegment segment = MemorySegment.allocateNative(4, scope); for (int i = 0; i \u0026lt; 4; i++) { MemoryAccess.setByteAtOffset(segment, i, (byte)\u0026#39;A\u0026#39;); } } 外部函数接口[取代Java本地接口] | JDK 17-? # public class HelloWorld { public static void main(String[] args) throws Throwable { try (ResourceScope scope = ResourceScope.newConfinedScope()) { CLinker cLinker = CLinker.getInstance(); MemorySegment helloWorld = CLinker.toCString(\u0026#34;Hello, world!\\n\u0026#34;, scope); MethodHandle cPrintf = cLinker.downcallHandle( CLinker.systemLookup().lookup(\u0026#34;printf\u0026#34;).get(), MethodType.methodType(int.class, MemoryAddress.class), FunctionDescriptor.of(CLinker.C_INT, CLinker.C_POINTER)); cPrintf.invoke(helloWorld.address()); } } } GC # G1, ZGC, 分代式 ZGC\n参考 # Java各个版本发布时间和主要特性整理！ Java 历史大版本及其详细特性介绍: Java 18 的新特性 JDK 19 JDK 20 JDK 21 Java19 虚拟线程原理介绍及实现 *** Java虚拟线程：异步编程之死 《深入剖析 Java 新特性》 范学雷 02,03,04,05,06,07,08,09,12, 13 从Java 11升级到Java 17 V 未 "},{"id":8,"href":"/www6vLang/docs/Golang/core/golangMap/","title":"Golang内置类型-Map","section":"core","content":"\nMap 内部实现 # map的内部结构 # hmap bucket topHash 快速定位key,以空间换时间 每个 bucket 的 tophash 区域其实是用来快速定位 key 位置的. 这是一种以空间换时间的思路。 key value Go 运行时采用了把 key 和 value 分开存储的方式，而不是采用一个 kv 接着一个 kv 的 kv 紧邻方式存储，这带来的其实是算法上的复杂性，但却减少了因内存对齐带来的内存浪费。 overflow bmap map的内部函数 [4] # mapassign 写 mapdelete 删 mapaccess 读 扩容 [2] # buckets \u0026amp;\u0026amp; oldbuckets 两种扩容方式 [渐进式扩容, 类似redis rehash] 因为 overflow bucket 过多导致的“扩容”，实际上运行时会新建一个和现有规模一样的 bucket 数组，然后在 assign 和 delete 时做排空和迁移。 因为当前数据数量超出 LoadFactor 指定水位而进行的扩容，那么运行时会建立一个两倍于现有规模的 bucket 数组，但真正的排空和迁移工作也是在 assign 和 delete 时逐步进行的。 扩容 [4] # 触发: mapassign 时机: load factor 过大 OR overflow bucket 过多 搬运过程: 渐进式\nmapassign elem cout \u0026gt; bucket*6.5 -\u0026gt; bigger size grow overflow too many \u0026ndash;\u0026gt; same size grow noverflow \u0026gt;=2^15 nvoerflow \u0026lt; 2^15 \u0026amp;\u0026amp; nvoerflow \u0026gt; bucket count map 解决 hash 冲突 [3] # 在 map 解决 hash /分桶 冲突问题时，实际上结合了拉链法和开放寻址法两种思路. 以 map 的插入写流程为例，进行思路阐述： （1）桶数组中的每个桶，严格意义上是一个单向桶链表，以桶为节点进行串联； （2）每个桶固定可以存放 8 个 key-value 对； （3）当 key 命中一个桶时，首先根据开放寻址法，在桶的 8 个位置中寻找空位进行插入； （4）倘若桶的 8 个位置都已被占满，则基于桶的溢出桶指针，找到下一个桶，重复第（3）步； （5）倘若遍历到链表尾部，仍未找到空位，则基于拉链法，在桶链表尾部续接新桶，并插入 key-value 对.\n缺陷 [4] # 已经扩容的map, 无法 缩容 保证并发安全时, 要手动读写锁，易出错 多核心下表现差 map的使用 # map的使用 # value没有任何的限制, key有严格的限制\n并发 # 不可以并发读写 可以并发读 参考 # Go面试题系列：Go map的底层实现原理 《16|复合数据类型：原始map类型的实现机制是这样的？》 TonyBai Golang map 实现原理 《09 神奇的内置数据结构》 V "},{"id":9,"href":"/www6vLang/docs/Golang/other/golangStudy/","title":"Golang 学习资源","section":"other","content":"\nGolang # 基础\n极客时间 《Go 并发编程实战课》 鸟窝 *** 极客时间 《Go语言从入门到实战》 好像看过 *** 极客时间 《Go 语言核心 36 讲》 郝林 ** 《Effective Go》 Effective Go 英文 高效的 Go 编程 Effective Go 中文 golang 编程规范 - Effective Go 中文 中文 50 Shades of Go 50 Shades of Go: Traps, Gotchas, and Common Mistakes for New Golang Devs\nGolang 新手可能会踩的 50 个坑 项目\u0026amp;进阶\n极客时间 《Go 语言项目开发实战》 孔令飞@腾讯 *** 极客训练营 《go进阶训练营 第4期》 bili V 毛剑 *** gotalk\ntalkgo @github Mix 0voice/Introduction-to-Golang ***\nGo 源码分析 Go source code analysis(zh-cn) 曹大 滴滴 ***\nbook Go语言圣经中文版 Go语言圣经（中文版） Go语言高级编程(Advanced Go Programming)\nGolang 个人blog # Tony Bai golang大神 *** 鸟窝 Java， golang 微博架构师 *** 罗道文 golang python NSQ 有深度 * 2017 停更 张晓龙 golang * 学习路线 # 学习路线 【上集】2022 年 Go 语言最全学习路线：十分钟带你过思维导图！ 【下集】2022 年 Go 语言最全学习路线：十分钟带你过思维导图！爆肝几天几夜整理的超详细 Go 学习 作者blog GOLANG ROADMAP *** GOLANG ROADMAP\n邀请码：caspar "},{"id":10,"href":"/www6vLang/docs/Java/concurrent/asyncReactive/","title":"异步化 Reactive","section":"并发","content":"\nReactive # ReactiveX An API for asynchronous programming with observable streams 响应式流（Reactive Stream） 具备“异步非阻塞”特性和“流量控制”能力的数据流. RSocket 是一个支持 reactive-stream 语义的开源网络通信协议，它将 reactive 语义的复杂逻辑封装了起来，使得上层可以方便实现网络程序。 Java8、RxJava、Reactor比较[11] # 核心特性 async，back-pressure(Stream) 全异步化 # 全异步化(基于消息和事件)【7,8】 框架 Akka （Actor+mailbox） 库 RxJava (Observable+event) 协议 RSocket 参考 # Reactive，ReactiveX # The introduction to Reactive Programming 全面异步化：淘宝反应式架构升级探索 Introduction to RSocket 我为什么不再推荐RxJava 八个层面比较 Java 8, RxJava, Reactor good reactivex 官网 reactive-streams-jvm git Reactive Streams （1）什么是响应式编程——响应式Spring的道法术器 未 （2）响应式流——响应式Spring的道法术器 未 "},{"id":11,"href":"/www6vLang/docs/Golang/core/golangSlice/","title":"Golang基础-Slice","section":"core","content":"\narray和slice # 数组长度是固定的， slice长度是可变的 slice底层实现 [2] # type slice struct { array unsafe.Pointer len int cap int } slice 初始化 [1] # 对于 make 来说，它可以初始化 slice 的 length 和 capacity，如果我们能确定 slice 里面会存放多少元素，从性能的角度考虑最好使用 make 初始化好，因为对于一个空的 slice append 元素进去每次达到阈值都需要进行扩容\nCode Example [1] # 参考 # [长文]从《100 Go Mistakes》我总结了什么？ gExamples slice_test.go 1.Go slice的底层实现原理? "},{"id":12,"href":"/www6vLang/docs/Golang/core/golangBugs/","title":"Golang 基础-Errors\u0026Bugs","section":"core","content":"\nErrors # 异常处理 [4] # Bugs # Golang 循环变量引用问题[7] 故障 [20] # CPU 用爆了？ 90%？ 内存用爆了？OOM？ Goroutine 用爆了？ 80w？ 线程数爆了？ 延迟太高？\n监控指标 [20] # goroutine数，线程数 goroutine 多， 通过pprof看goroutine在干啥，等锁 GC频率 GODEBUG=\u0026#39;gctrace=1\u0026#39; go run ./cmd/main.go MemStats 结构体 常规统计信息（General statistics） 分配堆内存统计（Heap memory statistics） 栈内存统计（Stack memory statistics） 堆外内存统计信息（Off-heap memory statistics） 垃圾回收器统计信息（Garbage collector statistics） 按 per-size class 大小分配统计（BySize reports per-size class allocation statistics） 问题排查套路 [20] # 阻塞问题\n排除外部问题 例如依赖的上游服务(db, redis, mq)延迟过高，在监控系统中查看 锁阻塞 减少临界区范围 降低锁粒度 Global lock -\u0026gt; sharded lock Global lock -\u0026gt; connection level lock Connection level lock -\u0026gt; request level lock 同步改异步 日志场景: 同步日志 -\u0026gt; 异步日志 Metric 上报场景: select -\u0026gt; select+default 个别场景使用双buffer 完全消灭阻塞 CPU占用过高 看CPU profile -\u0026gt; 优化占用CPU较多的部分逻辑\n应用逻辑导致 Json序列化 MD5算法hash成本太高 -\u0026gt; 使用cityhash, murmurhash 其他应用逻辑 -\u0026gt; 只能case by case分析 GC使用CPU过高 减少堆上对象分配 sync.Pool 进行堆对象重用 Map -\u0026gt; slice 指针 -\u0026gt; 非指针对象 多个小对象 -\u0026gt; 合并为一个大对象 offheap 降低GC频率 修改GOGC Make 全局大slice 调度相关的函数使用CPU过高 尝试使用goroutine pool 减少goroutine的创建与销毁 控制最大 goroutine数量 内存占用过高\n看prometheus 内存RSS是多少 oomkiller goroutine数量多少 普通任务 - goroutine不多， 重点关注heap profile中的inuse 定时任务类 - 需要看alloc goroutine栈占用多少 堆内存 占用内存空间过高 sync.Pool 对象复用 为不同大小的对象提供不同大小level的sync.Pool (参考fasthttp) offheap goroutine栈占用过多内存 减少goroutine数量 如每个连接一读一写 -\u0026gt; 合并为一个连接一个goroutine goroutine pool 限制最大 goroutine数量[21] 使用裸 epoll库(evio, gev等) 修改网络编程方式(只适用于对延迟不敏感的业务) 通过修改代码， 减少函数调用层级(难) goroutine数量过多\n从profile网页去看 goroutine在干什么 查死锁 阻塞问题 不在意延迟的选择第三方库优化 go压测工具 # wrk wrk2 Vegeta ghz 参考 # 【go实战系列五】 go1.19.2与pkg中error如何wrap与unwrap Errors | 将error进行wrap向上处理思想 | pkg/errors 随笔：Golang 循环变量引用问题以及官方语义修复 《28 直播：服务上线后 - 成为 Go 语言性能调优专家》 {% post_link \u0026lsquo;golangConcurrency\u0026rsquo; %} self "},{"id":13,"href":"/www6vLang/docs/Golang/concurrent/golangChannel/","title":"Golang内置类型-Channel","section":"concurrent","content":"\n实现 [1] # type hchan struct { qcount uint // total data in the queue dataqsiz uint // size of the circular queue buf unsafe.Pointer // points to an array of dataqsiz elements elemsize uint16 closed uint32 elemtype *_type // element type sendx uint // send index recvx uint // receive index recvq waitq // list of recv waiters sendq waitq // list of send waiters // lock protects all fields in hchan, as well as several // fields in sudogs blocked on this channel. // // Do not change another G\u0026#39;s status while holding this lock // (in particular, do not ready a G), as this can deadlock // with stack shrinking. lock mutex } type waitq struct { first *sudog last *sudog } 使用 # buffer channel vs. 非buffered channel # / 无缓冲 有缓冲 创建方式 make(chan TYPE) make(chan TYPE, SIZE) 发送阻塞 数据接收前发送阻塞 缓冲满时发送阻塞 接收阻塞 数据发送前接收阻塞 缓冲空时接收阻塞 3.Go channel有无缓冲的区别？\nchannel的读写 # 向关闭的channel中写入数据会panic 关闭的channel中读数据 有数据会读到数据，没数据会是nil Channel closing principle # [gpt] prompt: Golang的 Channel closing principle是什么？\n在Golang中，关闭一个Channel是一种重要的操作，如果不正确地关闭Channel，可能会导致程序出现死锁或其他问题。下面是Golang中Channel关闭的原则和细则：\n只有发送方才能关闭Channel。 发送方是指向Channel发送数据的goroutine，而接收方是指从Channel接收数据的goroutine。在Golang中，只有发送方才能关闭Channel，因为发送方知道何时不再需要发送数据，从而触发关闭Channel的操作。\n关闭Channel后，接收方仍然可以接收Channel中的数据。 当一个Channel被关闭后，接收方仍然可以从Channel中接收已经存在的数据，直到Channel中的所有数据都被接收完毕。这使得接收方可以在不知道Channel何时被关闭的情况下，安全地从Channel中接收数据。\n关闭一个已经关闭的Channel会导致panic。 如果尝试关闭一个已经关闭的Channel，会导致panic，因此在关闭Channel之前，应该先检查Channel是否已经关闭。\n关闭一个nil的Channel会导致panic。 如果尝试关闭一个nil的Channel，也会导致panic，因此在关闭Channel之前，应该先检查Channel是否为nil。\n关闭一个有缓冲的Channel时，仍然可以向其中发送数据。 当一个有缓冲的Channel被关闭时，发送方仍然可以向其中发送数据，直到Channel被填满。因此，在关闭一个有缓冲的Channel之后，可能还有一些数据需要被发送。\n关闭一个Channel会使Channel上的所有阻塞操作立即解除阻塞并返回。 当一个Channel被关闭时，Channel上的所有阻塞操作（包括接收和发送操作）都会立即解除阻塞并返回。对于接收操作，返回的值为Channel中剩余的数据，如果Channel已经为空，则返回类型的零值。对于发送操作，返回的结果通常为false，表示数据没有被发送成功。\n总之，关闭Channel是一项重要的操作，需要遵循一些原则和细则来保证程序的正确性和稳定性。在使用Channel的过程中，应该注意遵循这些原则和细则。 [/gpt]\n参考 # golang channel原理 *** 《09 神奇的内置数据结构》 channel 看动画 *** "},{"id":14,"href":"/www6vLang/docs/Golang/core/golangBasicLinter/","title":"Golang 基础-Linter","section":"core","content":"\nlinter [1] # 单个\ngolint go vet gocyclo 代码覆盖率 codecov 检查错误是否被处理 errcheck bodyclose sqlrows 集合\ngolangci-lint 标准 sonarqube deepsource golangci-lint + reviewdog [3]\n给项目提pr时，自动执行linter，自动CI？ github支持, gitlab也支持 name: actions on: push: branches: - master pull_request: types: - opened - reopened - synchronize - ready_for_review jobs: golangci-lint: if: ${{ !github.event.pull_request.draft }} name: runner / golangci-lint runs-on: ubuntu-latest steps: - name: Check out code uses: actions/checkout@v3 - name: golangci-lint uses: reviewdog/action-golangci-lint@v2 if: github.event_name == \u0026#39;pull_request\u0026#39; with: golangci_lint_flags: \u0026#34;--skip-dirs=mtls/crypto,module/http2 --enable-all --timeout=10m --exclude-use-default=false --tests=false --disable=gochecknoinits,gochecknoglobals,exhaustive,exhaustruct,exhaustivestruct,nakedret,ireturn,interfacer,tagliatelle,varnamelen\u0026#34; workdir: pkg 参考 # 《25 直播：如何写出优雅的 Go 代码》 static-analysis analysis-tools mosn的reviewdog "},{"id":15,"href":"/www6vLang/docs/Golang/other/golangFramework/","title":"Go Framework","section":"other","content":"\nWeb [1] # Httprouter radix tree\nchi\n最简单的框架 适合作为web框架入门项目 核心代码1200行+ Gin\n主要组件 router 支持分组 middleware\nbinding-decoder和validator logger context 老牌框架 核心代码3000行 echo\nFiber\n基于fasthttp beego\n微服务[1] # 组件 # config logger metrics Prometheus tracing OpenTelemetry registry MQ 依赖注入 wire，dig 框架 # GoMicro [2] + Go-Zero YOYOGO Dubbo GO Kratos[bili开源] goframe 本地缓存[3] # freecache bigcache fastcache Time \u0026amp;\u0026amp; cron[4] # 参考 # 《17 直播：社区优秀开源框架对比》 go-micro 源码解析 - server \u0026amp; client Golang 本地缓存选型对比及原理总结 一些关于时间和定时任务的库 Go 开源本地缓存组件选型对比（freecache、bigcache、fastcache 等） 未 鹅厂微创新Golang缓存组件TCache介绍 未 "},{"id":16,"href":"/www6vLang/docs/Golang/core/golangMemoryModel/","title":"Golang Rumtime-内存模型","section":"core","content":"\n系统内存管理[4] # 三个角色\nMutator [App] Allocator Bump/Sequential Allocator Free List Allocator First-Fit Next-Fit Best-Fit Segregated-Fit 工业界用的多, golang是这种类型的变种 Collector #2 栈内存管理\nmalloc \u0026lsquo;\u0026lt;128KB\u0026rsquo;\nprogram break \u0026lsquo;\u0026gt;=128KB\u0026rsquo; mmap Golang内存 # 内存分配 [4][5] # 三种类型 Tiny Small Large google tcmalloc 每个线程维护一个独立的内存池 多级别管理 4K， 8K， 16K \u0026hellip; 回收内存 放回预先分配的大块内存中 内存管理组件 mspan 68个规格， [8个字节\u0026hellip;32K] 双向链表 mcache 线程缓存 alloc tiny tinyoffset mcentral 管理全局的mspan供所有线程使用 noneempty mspan empty mspan mheap 管理动态分配内存, 持有的整个堆空间 arenas central 多级结构 mcache -\u0026gt; mcentral -\u0026gt; mheap 内存逃逸 [6] # 编译器会根据变量是否被外部引用来决定是否逃逸： 如果函数外部没有引用，则优先放到栈中； 如果函数外部存在引用，则必定放到堆中; 如果栈上放不下，则必定放到堆上; 内存泄漏 # 根因 [7][8]\ngoroutine泄漏 slice造成内存泄漏 原因 - 浅拷贝 time.Ticker造成内存泄漏 原因 - 没关闭timer cgo引起的内存泄漏 线程个数 常规分析手段 [8] 可以利用pprof对程序进行分析从而定位内存泄漏地址\n堆和栈 # 垃圾回收器 [9] #2 # Go语言的GC使用了**标记(mark)—清除(sweep)**技术\n系统结构 [1] # 现代计算机的多级存储结构 # cacheline 多核带来的问题 # 单变量的并发操作也必须用同步手段, 比如atomic 全局视角下观察到的多变量读写的顺序 可能会乱序 单变量 [2] # 单变量的原子读/写, 多核使用MESI协议保证正确性\n多变量 # 问题 乱序执行 内存重排\n解决方案 Memory barrier\nfalse sharing [3] # 因为CPU处理读写是以cache line为单位, 所以在并发修改变量时, 会一次性将其他CPU Core中的cache line invalidate 掉, 导致未修改的内存上相邻的变量也需要同步, 带来额外的性能负担\nHappen-before # 参考 # 《15 辅导 + 案例分析 + 答疑-更多课程》 体系课_Go高级工程师实战营(完结) *** MESI {% post_link \u0026lsquo;falseSharing\u0026rsquo; %} self 《13 Go 语言的内存管理与垃圾回收》 体系课_Go高级工程师实战营(完结) 1.Go 内存分配机制？ 2.Go 内存逃逸机制？ 浅谈Golang内存泄漏 code in git golang：快来抓住让我内存泄漏的“真凶”！ cgo引起的内存泄漏+常规分析手段 Go 垃圾回收器指南 {% post_link \u0026lsquo;javaMemoryModel\u0026rsquo; %} self "},{"id":17,"href":"/www6vLang/docs/Golang/concurrent/golangConcurrencyBug/","title":"Golang 并发Bug","section":"concurrent","content":"\n死锁 [1] # 通过pprof进入goroutine页面查看 [gpt] 在Golang中，互斥锁（Mutex）是不支持重入的，如果在一个goroutine中已经获得了互斥锁的锁并且没有释放，那么在同一个goroutine中再次尝试获取该锁时会导致死锁。\n这是因为互斥锁是一个排他锁，当一个goroutine获取了互斥锁的锁之后，其他的goroutine就不能再获取该锁，直到该goroutine释放该锁。如果同一个goroutine再次获取该锁，就会导致死锁。\n不过，在Golang中也提供了另外一种锁——读写锁（RWMutex），它是支持重入的。读写锁允许多个goroutine同时读取共享资源，但在写入时必须独占访问。读写锁内部有一个计数器，用于记录已经获取读锁的goroutine数量，因此同一个goroutine获取读锁是可以重入的。但是，当一个goroutine获取了写锁时，它不能再获取读锁，否则也会导致死锁。\n总之，互斥锁不支持重入，而读写锁支持重入。在使用锁的时候应该根据实际情况选择合适的锁来避免死锁的发生。 [/gpt]\nexample1 [1] # func m() { b.Lock() c.Lock() } func n() { c.Lock() b.Lock() } example2 # [gpt] 以下是一个可能导致死锁的Golang代码示例：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) func main() { var mu sync.Mutex c1 := make(chan int) go func() { mu.Lock() defer mu.Unlock() c1 \u0026lt;- 1 }() \u0026lt;-c1 mu.Lock() // 这里会导致死锁 defer mu.Unlock() fmt.Println(\u0026#34;Done\u0026#34;) } 在这个例子中，我们创建了一个互斥锁（Mutex）mu 和一个整数类型的无缓冲通道c1。接下来，我们在一个goroutine中获取了mu的锁，并在获取锁之后往c1通道中发送了一个整数1。在主goroutine中，我们从c1通道中接收1，然后再次试图获取mu的锁。但是，由于在此之前该锁已经在另一个goroutine中被获取并没有释放，因此会导致主goroutine被阻塞，从而导致死锁。\n解决这个问题的方法是在goroutine中释放锁，然后在主goroutine中再获取锁，如下所示：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) func main() { var mu sync.Mutex c1 := make(chan int) go func() { mu.Lock() defer mu.Unlock() c1 \u0026lt;- 1 }() \u0026lt;-c1 mu.Unlock() // 在goroutine中释放锁 mu.Lock() // 在主goroutine中再次获取锁 defer mu.Unlock() fmt.Println(\u0026#34;Done\u0026#34;) } 这个例子中，我们在goroutine中释放了锁，然后在主goroutine中再次获取锁，从而避免了死锁。\n[/gpt]\nbugs [1][2] # func finishReq(timeout time.Duration) r ob { - ch := make(chan ob) + ch := make(chan ob, 1) go func() { result := fn() ch \u0026lt;- result // block } select { case result = \u0026lt;- ch: return result case \u0026lt;- time.After(timeout): return nil } } Figure 1. A blocking bug caused by channel var group sync.WaitGroup group.Add(len(pm.plugins)) for _, p := range pm.plugins { go func(p *plugin) { defer group.Done() } - group.Wait() } + group.Wait() Figure 5. A blocking bug caused by WaitGroup. 参考 # 《15 辅导 + 案例分析 + 答疑-更多课程》 体系课_Go高级工程师实战营(完结) *** Understanding Real-World Concurrency Bugs in Go 规避 Go 中的常见并发 bug 未 理解真实项目中的 Go 并发 Bug 未 "},{"id":18,"href":"/www6vLang/docs/Golang/concurrent/golangConcurrency/","title":"Golang Concurrency","section":"concurrent","content":"\n并发 [2][1] # 并发原语 # sync.Once [3]\n保证在 Go 程序运行期间的某段代码只会执行一次 sync.Pool [3]\n两种场景中可以使用Pool做优化 进程中的inuse-objects数过多, gc mark 消耗大量CPU 进程中的inuse-objects数过多, 进程RSS占用过高 最佳实践 请求生命周期开始时，pool.Get, 请求结束时, pool.Put semaphore 信号量 [3]\n是锁的实现基础, 所有同步原语的基础设施 内部结构 treap tree+heap 二插搜索树 树上的每个节点都是一个链表 小顶堆 sync.Mutex 互斥锁 [3]\n内部结构 state 饥饿模式: 最新进自旋的goroutine优先级最高 非饥饿模式: 排队 sema 信号量 sync.RWMutex 读写锁 [3]\n内部结构 w writerSem readerSem readerCount readerWait sync.Map [3]\n线程安全的Map 内部结构 mu read dirty misses 设计 map+lock 多核扩展性差一点 sync.Map 在读多写少的情况下，基本上不需要加锁 sync.WaitGroup [3]\n等待一组 Goroutine 的返回 内部结构 state1 sync.Cond\n让一组的 Goroutine 都在满足特定条件时被唤醒 sync.Context\n进行上下文信息传递、提供超时和取消机制、控制子 goroutine 的执行 Context [6] # 进行上下文信息传递、提供超时和取消机制、控制子 goroutine 的执行\nfunc WithCancel(parent Context) (ctx Context, cancel CancelFunc) func WithDeadline(parent Context, d time.Time) (Context, CancelFunc) func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) context\n应用\u0026amp;扩展 # 控制 goroutine 的并发数量 [5] # 并发编程模式 [3][4] # fan-in 合并两个channel or channel 多个channel有任一个channel有返回, 就直接返回这个值。 pipeline 串联在一起的channel 扩展并发原语 # errgroup Semaphore SingleFlight\n参考 # GOLANG ROADMAP GOLANG ROADMAP\n邀请码：caspar 邀请码：Gopher-10645-1382 《Go 并发编程实战课》 极客时间 鸟窝 《15 辅导 + 案例分析 + 答疑-更多课程》 体系课_Go高级工程师实战营(完结) \u0026laquo; 14 | Channel：透过代码看典型的应用模式 \u0026raquo; Go 并发编程实战课 鸟窝 1.6 来，控制一下 goroutine 的并发数量 context 曹大 "},{"id":19,"href":"/www6vLang/docs/Golang/core/golangBasic/","title":"Golang 基础","section":"core","content":"\nRumtime [3] # Scheduler # GMP\nNetpoll # Memory # GC # 基础 # 内建函数 # init make() new() slice append() 用于切片(slice) 追加元素 copy() 只能用于数组切片内容赋值 size len() 计算数组(包括数组指针)、切片(slice)、map、channel、字符串等数据类型的长度 cap() 返回指定类型的容量 print() \u0026amp; println() resource reclaim close() delete() num complex() real() \u0026amp; imag() error handle panic() recover() others [6] clear()\n对于map对象: clear函数清空map对象的所有的元素 对于slice对象： clear函数将所有的元素设置为元素类型的零值，长度不变，容量不变 min() \u0026amp;\u0026amp; max() New vs Make # new和make是内置函数,主要用来分配内存空间 make make 仅用于 slice、map和 channel 的初始化，返回值为类型本身，而不是指针 new 只用于内存分配，且把内存清零 返回一个指向对应类型零值的指针 new() 一般 显示返回指针 func make(t Type, size ...IntegerType) Type func new(Type) *Type 9.Go 内置函数make和new的区别？\n值传递、引用传递 # Go语言中所有的传参都是值传递（传值），都是一个副本，一个拷贝。\n是否可以修改原内容数据，和传值、传引用没有必然的关系。在C++中，传引用肯定是可以修改原内容数据的，在Go语言里，虽然只有传值，但是我们也可以修改原内容数据，因为参数是引用类型\n引用类型和引用传递是2个概念，切记！！！\n类型\n非引用类型（int、string、struct等这些） 引用类型（指针、map、slice、chan等这些） 值传递\n将实参的值传递给形参，形参是实参的一份拷贝，实参和形参的内存地址不同。函数内对形参值内容的修改，是否会影响实参的值内容，取决于参数是否是引用类型 参数如果是非引用类型（int、string、struct等这些），这样就在函数中就无法修改原内容数据；如果是引用类型（指针、map、slice、chan等这些），这样就可以修改原内容数据。 引用传递 Go语言是没有引用传递的 在C++中，函数参数的传递方式有引用传递\nGo 函数参数传递到底是值传递还是引用传递？\nselect vs. switch # select只能应用于channel的操作 则会随机选取其中一个满足条件的分支 switch 分支是顺序执行的 Method \u0026amp; Function # Method 方法(Method)是一个带有receiver的函数Function Receiver[5] 参考 # GOLANG ROADMAP GOLANG ROADMAP\n邀请码：caspar 邀请码：Gopher-10645-1382 极客时间 《Go 并发编程实战课》 鸟窝 《04 Go 程序是怎么跑起来的》 xxx golang 方法接收者 mycode-go 你知道吗？Go新增加了三个内建函数 Golang高性能编程实践 *** 未 "},{"id":20,"href":"/www6vLang/docs/Golang/core/golangGMP/","title":"Golang Rumtime-GMP","section":"core","content":"\nGoroutine的调度 # Overview System Thread : kernel entity Processor : go实现的协程处理器 Goroutine : 协程\n组件 # 组件 G: goroutine, 一个计算任务。 由需要执行的代码和其上下文组成, 上下文包括: 当前代码位置, 栈顶、 栈底地址，状态等。 M: machine, 系统线程, 执行实体, 想要在CPU上执行代码, 必须有线程 P: processor, 虚拟处理器, M必须获得P才能执行代码, 否则必须陷入休眠(后台监控线程除外).\n组件之间的关系 Processor在不同的系统线程里, 每个Processor挂载着一个协程队列，Processor依次调用Gorouine， 只有一个Gorouine是正在运行状态的。\nP 和 M 的个数问题 [1]\nP 的数量 在程序执行的任意时刻都只有 $GOMAXPROCS 个 goroutine 在同时运行 M 的数量 go 程序启动时，会设置 M 的最大数量，默认 10000 一个 M 阻塞了，会创建新的 M。 M 与 P 的数量没有绝对关系，一个 M 阻塞，P 就会去创建或者切换另一个 M，所以，即使 P 的默认数量是 1，也有可能会创建很多个 M 出来。\nP 和 M 何时会被创建 [1]\nP 何时创建 在确定了 P 的最大数量 n 后，运行时系统会根据这个数量创建 n 个 P。 M 何时创建 没有足够的 M 来关联 P 并运行其中的可运行的 G。 比如所有的 M 此时都阻塞住了，而 P 中还有很多就绪任务，就会去寻找空闲的 M，而没有空闲的，就会去创建新的 M 看参考文档里的图 协程跟线程是有区别的，线程由 CPU 调度是抢占式的，协程由用户态调度是协作式的，一个协程让出 CPU 后，才执行下一个协程。\n场景 # 处理阻塞[能被runtime拦截到的阻塞-非阻塞] [2]\n在线程发生阻塞的时候，不会无限制的创建线程 以下这些情况, 会把goroutine挂起，让g先进某个数据结构，待ready后再继续执行 不会占用线程， 线程会进入schedule，继续消费队列，执行其他的g 处理阻塞[不能被runtime拦截到的阻塞-阻塞] [2]\n两种情况 CGO 阻塞在syscall上时, 必须占用一个线程 sysmon, 在专有线程中执行, 不需要绑定P就可以执行 checkdead 常见误解 这个可以检查死锁 netpoll inject g list to global runqueue retake 如果syscall卡了很久，就把p剥离(handoffp) #1 如果用户g运行了很久, 就发信号SIGURG抢占 case\ncase1 一个协程运行时间运行的特别长。 守护线程计数， 如果processor完成的goroutine数量一直不变。在这个协程的任务栈里插入一个中断的标记，读到这个中断标记后，goroutine会把自己中断下来插入到等待队列的队尾。 case2 某个协程被io中断后， Processer会把自己移动到另一个可用的系统线程当中， 执行队列里的任务。 当这个协程io中断被唤醒后，会把自己加入到某个Processor的队列里， 或者加入到全局的等待队列里。 调度器的设计策略 [1]\nwork stealing 机制 hand off 机制 #1 生产端 [2] # 消费端 [2] # 参考 # Golang的GMP原理与调度 *** 《04 Go 程序是怎么跑起来的》 *** #64 深入浅出 Golang Runtime 【 Go 夜读 】 goroutine , go network , gc *** 未 Golang深入理解GPM模型 *** 未 "},{"id":21,"href":"/www6vLang/docs/Java/concurrent/reactive/","title":"Reactive-Actor","section":"并发","content":"\nReactive # Akka \u0026amp;\u0026amp; Actor # / Responsive Resilient Elastic Message Driven Akka Actor and Stream Supervisor策略 Load balance and adptive routing（dispatcher） mail-box, private State， backpressure Actor 允许的操作\ncreate Actor Send message desigate how to handle the next message Actor Message： Simple，Immutable data structures\nActor Actors process only one message at a time\nActor 类型： Local actor Remote actor\n哪些系统在用Akka Flink， spark 2.0从Akka迁移到Netty play framework（web）\n参考： # 5分钟理解分布式架构Actor模型 The Reactive Manifesto\n"},{"id":22,"href":"/www6vLang/docs/Hybrid/paradigm/","title":"范式Paradigm-语言","section":"Hybrid","content":"\n语言范式 # 面向对象 # 函数式 # 成熟度 Clojure Scala，Java， Javascript\nFunction is First Class 闭包; 高阶函数; 柯里化： Scala的柯里化 部分施用 partial：Scala的部分施用 【更加接近人的语言】\n并行 Java Lamda，Java Stream Spark算子（基本构造单元）\n效率 Scala的效率生产率是Java的2-3倍， Scala 10行代码Java要20-30行\n面向过程 # 【用了面向对象语言写出的不一定是面向对象的代码】\n语言编程范式 # 传引用 # JAVA（native）, C++指针\n传值 # Java的clone浅拷贝 vs 深拷贝 ， C++拷贝构造\n所有权 # Rust， C++ move所有权\n语言编程范式 # 命令式 # 申明式 # Spring Annotation 申明式 K8S yaml 申明式\n并发范式 # 多线程 +锁 # Java\nCSP 协程 # Golang，Rust，\nC++， Python， Lua Java协程框架\nActor # Scala Akka\n函数式 # 分离标识与状态 # Clojure\nFuture + Promise # "},{"id":23,"href":"/www6vLang/docs/Hybrid/javaAndGoConcurrent/","title":"Java和Go的并发","section":"Hybrid","content":"\nJava和Go的并发 # Java和Go的并发 # 用户线程和系统线程之间的关系（M:N，1:1） # "},{"id":24,"href":"/www6vLang/docs/Java/other/designPatternsInJava/","title":"Java里的设计模式","section":"Other","content":"\n参考 # JDK里的设计模式 Examples of GoF Design Patterns in Java\u0026rsquo;s core libraries Java 设计模式 未 图说设计模式 未 常用开源框架中设计模式使用分析（全） 阿里加多 *** 未 设计模式概览图 *** 未 "},{"id":25,"href":"/www6vLang/docs/Java/other/optimize/","title":"JVM性能调优","section":"Other","content":"\n参考 # 从实际案例聊聊Java应用的GC优化 录录\n"},{"id":26,"href":"/www6vLang/docs/Java/concurrent/async/","title":"异步化 总结","section":"并发","content":"\n异步编程范式-Callback [0] # Continuation == 回调函数 # 编程模式 Continuation-passing style（CPS） 把调用者 f() 还未执行的部分包成一个函数对象 cont，一同传给被调用者 g()； 正常运行 g() 函数体； g() 完成后，连同它的结果一起回调 cont，从而继续执行 f() 里剩余的代码。\nCallback实现 # 而异步 IO 中，进程发起 IO 操作时也会一并输入回调（也就是 Continuation），这大大解放了生产力 —— 现场无需等待，可以立即返回去做其他事情。一旦 IO 成功后，AIO 的 Event Loop 会调用刚刚设置的回调函数，把剩下的工作完成。这种模式有时也被称为 Fire and Forget。 通过实现的 Continuation，线程不再受 IO 阻塞，可以自由自在地跑满 CPU。\nCallback语法糖：Promise # Promise 是对异步调用结果的一个封装，在 Java 中它叫作 CompletableFuture 或者 ListenableFuture (Guava)。 Promise 改善了 Callback 的可读性，也让异常处理稍稍优雅了些。\n反应式编程(Promise 的极大增强) # 相比 Promise，反应式引入了流（Flow）的概念。\n异步编程范式- Coroutine [0] # CPS 变换：Coroutine 与 async/await # 在异步函数调用时加上 await，编译器就会自动把它转化为协程（Coroutine），而非昂贵的线程。\n用户态线程 # goroutine\n并行 范式/编程模型 # 并行 范式/编程模型 系统/语言 线程和锁 Java 函数式(Future，Promise） Java8 Streaming API, lambda表达式\nSpark/Flink 算子\nClojure reducer 分离标识和状态 Clojure Actor Scala Actor, Akka CSP Golang协程, Kotlin协程 Reactive RxJava\nFlux (Reactor Core)\nRSocket 参考 # 异步编程的几种方式 *** google Guava包的ListenableFuture解析 罗立树 谈谈服务化体系中的异步（上） 花钱的年华 苏宁 11.11：如何基于异步化打造会员任务平台？-基于异步化的性能优化实践 葛苏杰 Web服务请求异步化介绍（概念篇） 放翁（文初） *** Java中的纤程库 - Quasar 鸟窝 SEDA: An Architecture for Well-Conditioned, Scalable Internet Services 《七周七并发》 "},{"id":27,"href":"/www6vLang/docs/Java/core/collection/","title":"Java集合总结","section":"Core","content":"\n参考： # JDK Collection 源代码 关于Java集合的小抄 白衣 限流系统如何发现系统的热点 阿里中间件团队博客 不正当使用HashMap导致cpu 100%的问题追究 王宏江 并发环境下HashMap引起的full gc排查 ol_beta 不止JDK7的HashMap，JDK8的ConcurrentHashMap也会造成CPU 100% 朱小厮 朱忠华 "},{"id":28,"href":"/www6vLang/docs/Java/core/aop/","title":"AOP总结","section":"Core","content":"\n参考: # 1.AOP技术讨论 乒乓狂魔 2.AOP 那点事儿 黄勇 3.AOP 那点事儿（续集） 黄勇 4.AOP实现机制 fantasy 5.动态代理方案性能对比 javatar 6.Java动态代理机制详解（JDK 和CGLIB，Javassist，ASM） 亦山 7.Spring事务处理时自我调用的解决方案及一些实现方式的风险 张开涛\n"},{"id":29,"href":"/www6vLang/docs/Java/core/classloaderSummarize/","title":"Classloader总结","section":"Core","content":"\n参考: # 深入浅出ClassLoader 你真的了解ClassLoader吗？ 魏 鹏 class卸载、热替换和Tomcat的热部署的分析 heavensay 《实战Java虚拟机》 第10章 "},{"id":30,"href":"/www6vLang/docs/Java/core/gc/","title":"垃圾收集GC总结","section":"Core","content":"\n并发标记算法 # CMS： 三色标记算法 + 增量更新（Incremental update） G1： 三色标记算法 + STAB（snapshot-at-the-beginning） Java虚拟机 \u0026mdash;-三色标记与G1垃圾回收器 参考： # 源码分析：Java对象的内存分配 iceAeterna 《深入理解Java虚拟机（第2版）》 第3章 周志明 深入理解GC ——MinorGC\\MajorGC\\FullGC 张硕的博客 触发JVM进行Full GC的情况及应对策略 yexx Netty之有效规避内存泄漏 江南白衣 周期性Full GC的异常排查 weiplex 一个大对象引起的血案，GC的踩坑实录 何锦彬 生产环境下持久带满导致FullGC，如何跟踪 又是一个程序员粗心的代码引起频繁FullGC的案例 微信公众号里的 JVM初探- 使用堆外内存减少Full GC 菜鸟-翡青 我遇到tomcat 7 full gc频繁的问题 auzll 一次堆外OOM问题的排查过程 谢照东 占小狼的博客 美团三面：一个线程OOM，进程里其他线程还能运行么？ 孤独烟 Java技术驿站 netty 堆外内存泄露排查盛宴 闪电侠的博客 netty的bug 线上故障排查(2) - Java应用故障之堆溢出OOM问题及排查方案 冯立彬 未 "},{"id":31,"href":"/www6vLang/docs/Java/concurrent/threadNum/","title":"线程池最佳线程数","section":"并发","content":"\n最佳实践: 曾经遇到过任务被丢给线程池之后，长时间都没有被执行的诡异问题。最初，我认为这是代码的 Bug 导致的，后来经过排查发现，是因为线程池的coreThreadCount 和 maxThreadCount 设置的比较小，导致任务在线程池里面大量的堆积，在调大了这两个参数之后问题就解决了.\n参考: # 工作线程数究竟要设置为多少 架构师之路 蚂蚁金服技术专家总结：性能优化的常见招式 jurassic_1 《Java 并发编程实践》 8.2定制线程池的大小 Brian Goetz 高并发系统设计40问 - 07 | 池化技术：如何减少频繁创建数据库连接的性能损耗？ 唐扬 ​\n"},{"id":32,"href":"/www6vLang/docs/Java/concurrent/volatile-CAS/","title":"多线程中的volatile和CAS","section":"并发","content":"\n参考: # Java 理论与实践: 正确使用 Volatile 变量 从volatile解读ConcurrentHashMap（jdk1.6.0）无锁读 为什么volatile不能保证原子性而Atomic可以 阿里巴巴Java开发手册 非阻塞同步算法与CAS(Compare and Swap)无锁算法 非阻塞算法在并发容器中的实现 程晓明 "},{"id":33,"href":"/www6vLang/docs/Java/concurrent/lock/","title":"多线程中的锁","section":"并发","content":"\n参考 # 《java并发编程实践》 13章 显示锁 ,13.5 读-写锁 轻松学习java可重入锁(ReentrantLock)的实现原理 锁模式 -\u0026gt; 共享锁，排他锁 轻松掌握java读写锁(ReentrantReadWriteLock)的实现原理 Java中的读/写锁 作者:Jakob Jenkov Java同步块 作者:Jakob Jenkov 《Java并发编程的艺术》-Java并发包中的读写锁及其实现分析 怎么理解Condition 码梦为生|刘锟洋 多线程之：偏向锁，轻量级锁，重量级锁 无信不立 "},{"id":34,"href":"/www6vLang/docs/Java/concurrent/thread/","title":"Java多线程总结","section":"并发","content":"\n参考： # 非阻塞同步算法与CAS(Compare and Swap)无锁算法 高性能队列——Disruptor java多线程体系 东隼 《并发编程实践》 Brian Goetz 第3章 Java并发之AQS详解 waterystone 面试官：线程顺序执行,这么多答案你都答不上来？ Join, wait, Condition, 线程池 "},{"id":35,"href":"/www6vLang/docs/Java/concurrent/cancelAndShutdown/","title":"Java多线程中的取消和关闭","section":"并发","content":"\n取消和关闭 基础 中断状态 中断请求 取消点 任务取消 取消策略（how/when/what） how/when volatile的取消状态+非阻塞方法(正确) volatile的取消状态+阻塞方法(错误) 中断的状态显示的检查（正确）.Thread.currentThread().isInterrupted() what, 中断策略（如何响应中断请求） InterruptedException传递给调用者，捕获后恢复中断的状态，Thread.currentThread().interrupted(). 封装成shutdown方法 通过Future.cancel来取消任务 中断当前线程 阻塞函数 抛出InterruptedException Thread.isInterrupted()返回false eg. Object的wait(),Thread的join(),sleep() IO上的阻塞 BIO Socket读写网络 JDBC驱动MySQL-connector-java nio InterruptibleChannel InterruptibleChannel将被关闭 抛出ClosedByInterruptException Thread.isInterrupted()返回true Selector Selector#select()方法将立即返回 不会抛出异常 Thread.isInterrupted()返回true 服务取消 生命周期方法 start() stop() ExceuteService.shutDown()/shutDownNow() 致命药丸(akka的Poison Pill) 锁中断 不可中断 内部锁synchronized, ReentrantLock.lock() 可中断 显示锁ReentrantLock.tryLock()，.lockInterruptibly() "},{"id":36,"href":"/www6vLang/docs/Java/core/javaMemoryLeak/","title":"Java内存泄漏的案例和解决方案","section":"Core","content":"\n如果一个可达对象的生命周期很长，它有一个生命周期较短的对象引用，此时就可能出现Java内存泄漏。也即是说， 造成内存泄漏的原因是对象虽然可达但不是活动的。\n避免内存泄漏的三种方式 # 1. 软引用 # 对于缓存，如果没有合适的策略让老的缓存项目到期就可能遇到内存泄漏。\n我们希望缓存能用上所有的可用内存，只是在需要额外资源的时候才释放资源。 通过软可达可以实现资源的释放。\n释放软可达对象的规则：\nI. gc抛出OOM异常之前要尝试释放软引用\nII. gc以LRU的顺序释放软引用\n举例：\nGoogle LoadingCache中的CacheBuilder.softValues()\n2. 弱引用 # 弱引用可以用于协助垃圾回收， 这是通用的解决方案。\n举例： threadLocal\n每个线程中有一个Map, 这个Map的类型是ThreadLocal.ThreadLocalMap. Map中的key为一个threadlocal实例. 这个Map的key使用了弱引用。 每个key都弱引用指向threadlocal. 当把threadlocal实例置为null以后,没有任何强引用指向threadlocal实例,所以threadlocal将会被gc回收.\nps: value却不能回收,因为存在一条从current thread连接过来的强引用. 只有当前thread结束以后, current thread就不会存在栈中,强引用断开, Current Thread, Map, value将全部被GC回收. 如果使用线程池，线程的强引用会长时间的存在，为了防止内存泄漏，最好的做法是将调用threadlocal的remove方法。\n3. 打开(增加)和关闭（删除）方法成对出现 # 资源申请和回收不成对会使资源没释放，造成内存泄漏。\n举例：\nI. 在finally块中关闭打开的资源和异常处理。\nII. 使用try-with-resources语句（Java SE7新特性）\ntry (BufferedReader br = new BufferedReader(new FileReader(path))) {\rreturn br.readLine();\r} 内存泄漏案例 # \u0026laquo;实战Java虚拟机——JVM故障诊断与性能优化\u0026raquo; 7.2.2节中有关JDK6.0里String.substring()可能引发的内存泄漏\n\u0026laquo; Effective.Java.中文版 - 第二版\u0026raquo; - 第六条 消除过期的对象引用 如果一个类自己管理内存，程序员就要警惕内存泄漏问题。\n大量static字段引起的内存泄漏\n不正确的equals()和hashCode()实现\n常量字符串造成的内存泄漏\n参考 # 1 . 了解Java中的内存泄漏 作者:baeldung 译者:thornhill\n"},{"id":37,"href":"/www6vLang/docs/Java/core/javaString/","title":"Java 字符串","section":"Core","content":"\n"},{"id":38,"href":"/www6vLang/docs/Java/core/javaMemoryModel/","title":"Java内存模型","section":"Core","content":"\n参考: # JVM内部原理 原文作者：James D Bloom 翻译：梅小西 浅谈HotSpot逃逸分析 占小狼 class卸载、热替换和Tomcat的热部署的分析 heavensay java自定义classloader引发的思考 editice 《深入理解java虚拟机》 第二章 周志明 浅谈Java String内幕 占小狼 JMM和底层实现原理 王侦 *** 未 "},{"id":39,"href":"/www6vLang/docs/Java/concurrent/concurrentCollection/","title":"Java并发容器总结","section":"并发","content":"\n参考: # 关于Java集合的小抄 白衣 谈谈ConcurrentHashMap1.7和1.8的不同实现 占小狼 高性能队列——Disruptor 非阻塞算法在并发容器中的实现 程晓明 从volatile解读ConcurrentHashMap（jdk1.6.0）无锁读 绫萱 JAVA并发容器代码随读 BucketLi 聊聊并发（四）深入分析ConcurrentHashMap 方 腾飞 Java8 新特性之流式数据处理 深蓝至尊 不止JDK7的HashMap，JDK8的ConcurrentHashMap也会造成CPU 100% 朱小厮 朱忠华 "}]