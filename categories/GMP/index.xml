<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>GMP on Language</title>
    <link>https://www6v.github.io/Lang/categories/GMP/</link>
    <description>Recent content in GMP on Language</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Tue, 08 Mar 2022 12:15:08 +0000</lastBuildDate>
    <atom:link href="https://www6v.github.io/Lang/categories/GMP/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Golang Rumtime-GMP</title>
      <link>https://www6v.github.io/Lang/docs/Golang/core/golangGMP/</link>
      <pubDate>Tue, 08 Mar 2022 12:15:08 +0000</pubDate>
      <guid>https://www6v.github.io/Lang/docs/Golang/core/golangGMP/</guid>
      <description>Goroutine的调度 # Overview System Thread : kernel entity Processor : go实现的协程处理器 Goroutine : 协程&#xA;组件 # 组件 G: goroutine, 一个计算任务。 由需要执行的代码和其上下文组成, 上下文包括: 当前代码位置, 栈顶、 栈底地址，状态等。 M: machine, 系统线程, 执行实体, 想要在CPU上执行代码, 必须有线程 P: processor, 虚拟处理器, M必须获得P才能执行代码, 否则必须陷入休眠(后台监控线程除外).&#xA;组件之间的关系 Processor在不同的系统线程里, 每个Processor挂载着一个协程队列，Processor依次调用Gorouine， 只有一个Gorouine是正在运行状态的。&#xA;P 和 M 的个数问题 [1]&#xA;P 的数量 在程序执行的任意时刻都只有 $GOMAXPROCS 个 goroutine 在同时运行 M 的数量 go 程序启动时，会设置 M 的最大数量，默认 10000 一个 M 阻塞了，会创建新的 M。 M 与 P 的数量没有绝对关系，一个 M 阻塞，P 就会去创建或者切换另一个 M，所以，即使 P 的默认数量是 1，也有可能会创建很多个 M 出来。</description>
    </item>
  </channel>
</rss>
