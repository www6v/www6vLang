<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>范式 on Language</title>
    <link>https://www6v.github.io/www6vLang/categories/%E8%8C%83%E5%BC%8F/</link>
    <description>Recent content in 范式 on Language</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Sun, 08 Nov 2020 17:34:42 +0000</lastBuildDate>
    <atom:link href="https://www6v.github.io/www6vLang/categories/%E8%8C%83%E5%BC%8F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>范式Paradigm-语言</title>
      <link>https://www6v.github.io/www6vLang/docs/Hybrid/paradigm/</link>
      <pubDate>Sun, 08 Nov 2020 17:34:42 +0000</pubDate>
      <guid>https://www6v.github.io/www6vLang/docs/Hybrid/paradigm/</guid>
      <description>语言范式 # 面向对象 # 函数式 # 成熟度 Clojure Scala，Java， Javascript&#xA;Function is First Class 闭包; 高阶函数; 柯里化： Scala的柯里化 部分施用 partial：Scala的部分施用 【更加接近人的语言】&#xA;并行 Java Lamda，Java Stream Spark算子（基本构造单元）&#xA;效率 Scala的效率生产率是Java的2-3倍， Scala 10行代码Java要20-30行&#xA;面向过程 # 【用了面向对象语言写出的不一定是面向对象的代码】&#xA;语言编程范式 # 传引用 # JAVA（native）, C++指针&#xA;传值 # Java的clone浅拷贝 vs 深拷贝 ， C++拷贝构造&#xA;所有权 # Rust， C++ move所有权&#xA;语言编程范式 # 命令式 # 申明式 # Spring Annotation 申明式 K8S yaml 申明式&#xA;并发范式 # 多线程 +锁 # Java</description>
    </item>
  </channel>
</rss>
