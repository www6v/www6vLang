<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>基础 on Language</title>
    <link>https://www6v.github.io/Lang/categories/%E5%9F%BA%E7%A1%80/</link>
    <description>Recent content in 基础 on Language</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Thu, 22 Sep 2022 14:05:36 +0000</lastBuildDate>
    <atom:link href="https://www6v.github.io/Lang/categories/%E5%9F%BA%E7%A1%80/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Golang内置类型-Map</title>
      <link>https://www6v.github.io/Lang/docs/Golang/core/golangMap/</link>
      <pubDate>Thu, 22 Sep 2022 14:05:36 +0000</pubDate>
      <guid>https://www6v.github.io/Lang/docs/Golang/core/golangMap/</guid>
      <description>Map 内部实现 # map的内部结构 # hmap bucket topHash 快速定位key,以空间换时间 每个 bucket 的 tophash 区域其实是用来快速定位 key 位置的. 这是一种以空间换时间的思路。 key value Go 运行时采用了把 key 和 value 分开存储的方式，而不是采用一个 kv 接着一个 kv 的 kv 紧邻方式存储，这带来的其实是算法上的复杂性，但却减少了因内存对齐带来的内存浪费。 overflow bmap map的内部函数 [4] # mapassign 写 mapdelete 删 mapaccess 读 扩容 [2] # buckets &amp;amp;&amp;amp; oldbuckets 两种扩容方式 [渐进式扩容, 类似redis rehash] 因为 overflow bucket 过多导致的“扩容”，实际上运行时会新建一个和现有规模一样的 bucket 数组，然后在 assign 和 delete 时做排空和迁移。 因为当前数据数量超出 LoadFactor 指定水位而进行的扩容，那么运行时会建立一个两倍于现有规模的 bucket 数组，但真正的排空和迁移工作也是在 assign 和 delete 时逐步进行的。 扩容 [4] # 触发: mapassign 时机: load factor 过大 OR overflow bucket 过多 搬运过程: 渐进式</description>
    </item>
    <item>
      <title>Golang基础-Slice</title>
      <link>https://www6v.github.io/Lang/docs/Golang/core/golangSlice/</link>
      <pubDate>Sat, 09 Jul 2022 18:43:02 +0000</pubDate>
      <guid>https://www6v.github.io/Lang/docs/Golang/core/golangSlice/</guid>
      <description>&#xA;array和slice # 数组长度是固定的， slice长度是可变的 slice底层实现 [2] # type slice struct { array unsafe.Pointer len int cap int } slice 初始化 [1] # 对于 make 来说，它可以初始化 slice 的 length 和 capacity，如果我们能确定 slice 里面会存放多少元素，从性能的角度考虑最好使用 make 初始化好，因为对于一个空的 slice append 元素进去每次达到阈值都需要进行扩容&#xA;Code Example [1] # 参考 # [长文]从《100 Go Mistakes》我总结了什么？ gExamples slice_test.go 1.Go slice的底层实现原理? </description>
    </item>
    <item>
      <title>Golang 基础-Errors&amp;Bugs</title>
      <link>https://www6v.github.io/Lang/docs/Golang/core/golangBugs/</link>
      <pubDate>Thu, 07 Jul 2022 11:59:53 +0000</pubDate>
      <guid>https://www6v.github.io/Lang/docs/Golang/core/golangBugs/</guid>
      <description>Errors # 异常处理 [4] # Bugs # Golang 循环变量引用问题[7] 故障 [20] # CPU 用爆了？ 90%？ 内存用爆了？OOM？ Goroutine 用爆了？ 80w？ 线程数爆了？ 延迟太高？&#xA;监控指标 [20] # goroutine数，线程数 goroutine 多， 通过pprof看goroutine在干啥，等锁 GC频率 GODEBUG=&amp;#39;gctrace=1&amp;#39; go run ./cmd/main.go MemStats 结构体 常规统计信息（General statistics） 分配堆内存统计（Heap memory statistics） 栈内存统计（Stack memory statistics） 堆外内存统计信息（Off-heap memory statistics） 垃圾回收器统计信息（Garbage collector statistics） 按 per-size class 大小分配统计（BySize reports per-size class allocation statistics） 问题排查套路 [20] # 阻塞问题&#xA;排除外部问题 例如依赖的上游服务(db, redis, mq)延迟过高，在监控系统中查看 锁阻塞 减少临界区范围 降低锁粒度 Global lock -&amp;gt; sharded lock Global lock -&amp;gt; connection level lock Connection level lock -&amp;gt; request level lock 同步改异步 日志场景: 同步日志 -&amp;gt; 异步日志 Metric 上报场景: select -&amp;gt; select+default 个别场景使用双buffer 完全消灭阻塞 CPU占用过高 看CPU profile -&amp;gt; 优化占用CPU较多的部分逻辑</description>
    </item>
    <item>
      <title>Golang 基础</title>
      <link>https://www6v.github.io/Lang/docs/Golang/core/golangBasic/</link>
      <pubDate>Tue, 08 Mar 2022 23:07:50 +0000</pubDate>
      <guid>https://www6v.github.io/Lang/docs/Golang/core/golangBasic/</guid>
      <description>Rumtime [3] # Scheduler # GMP&#xA;Netpoll # Memory # GC # 基础 # 内建函数 # init make() new() slice append() 用于切片(slice) 追加元素 copy() 只能用于数组切片内容赋值 size len() 计算数组(包括数组指针)、切片(slice)、map、channel、字符串等数据类型的长度 cap() 返回指定类型的容量 print() &amp;amp; println() resource reclaim close() delete() num complex() real() &amp;amp; imag() error handle panic() recover() others [6] clear()&#xA;对于map对象: clear函数清空map对象的所有的元素 对于slice对象： clear函数将所有的元素设置为元素类型的零值，长度不变，容量不变 min() &amp;amp;&amp;amp; max() New vs Make # new和make是内置函数,主要用来分配内存空间 make make 仅用于 slice、map和 channel 的初始化，返回值为类型本身，而不是指针 new 只用于内存分配，且把内存清零 返回一个指向对应类型零值的指针 new() 一般 显示返回指针 func make(t Type, size .</description>
    </item>
  </channel>
</rss>
