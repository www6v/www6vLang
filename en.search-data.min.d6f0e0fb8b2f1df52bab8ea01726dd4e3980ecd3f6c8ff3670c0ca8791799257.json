[{"id":0,"href":"/Lang/docs/Java/","title":"Java","section":"Lang","content":"test\n"},{"id":1,"href":"/Lang/docs/Golang/","title":"Java","section":"Lang","content":"test\n"},{"id":2,"href":"/Lang/docs/Java/core/javaFeature/","title":"Java Feature","section":"Core","content":"\n版本 # 版本 发布日期 JDK 19 2022/09/20 JDK 20 2023/03/21 版本+特性 [1] # Java 1.4 # NIO（New I/O） Java 5（Java 1.5） # 泛型 自动装箱/拆箱 枚举类型 Java 7 # Try-with-resources Java SE 8（Java 8）- LTS长期支持版本 # Lambda 表达式：简化函数式编程。允许以更简洁的语法编写函数式接口的实例，使代码更加简洁。 Stream API：用于处理集合，支持函数式操作，如过滤、映射和聚合。 方法引用：允许直接引用现有方法或构造函数，避免了重复编写类似的代码。 接口的默认方法：在接口中提供默认实现，提高接口的灵活性。 时间 API：提供了一组强大的时间操作类，简化了日期和时间的操作。 重复注解：允许在同一个地方多次声明同一个注解，提高了代码的可读性。 CompletableFuture 类：简化异步编程，提供更好的错误处理和异常处理机制。 Nashorn 引擎：提供了一种基于 JavaScript 的解决方案，允许将 JavaScript 代码嵌入到 Java 应用程序中。 Optional 类：减少空指针异常，提高代码可读性。 Java SE 9（Java 9） # 模块系统（Project Jigsaw）：将 Java 的庞大代码库划分为可重用的模块，简化大型应用的构建和维护。 JShell：Java 的交互式命令行工具，用于快速尝试和测试 Java 代码片段。 新的集合工厂方法：方便地创建不可变集合，如 List.of()、Set.of() 和 Map.of()。 Java SE 10（Java 10） # 局部变量类型推断：使用 var 关键字自动推断局部变量的类型，简化代码。 垃圾收集器接口改进：提高了垃圾收集器的可插拔性和灵活性。 Java SE 11（Java 11）-LTS长期支持版本 # 新的 HTTP 客户端 API：支持 HTTP/2 和 WebSocket，提供了更现代化的编程方式。 改进的垃圾收集：引入了 ZGC 和 Epsilon 垃圾收集器。 String 类的新方法：如 lines()、isBlank()、strip() 等。 Java SE 12（Java 12） # switch 表达式：允许在 switch 语句中使用表达式，提高了代码的可读性和简洁性。 改进的字符串类：提供了一些新的方法，使得字符串的操作更加方便和高效。 Shenandoah 垃圾回收器：提供了一种低停顿时间的垃圾回收器，适用于大型堆内存的应用程序。 微基准测试套件：提供了一种用于快速测试性能的微基准测试框架。 JDK 源代码重构：对 JDK 源代码进行了重构，提高了代码的可读性和维护性。 Java SE 13 （Java 13） # 文本块：允许以更简洁的语法创建多行字符串，提高了代码的可读性和简洁性。 改进的 switch 表达式：允许在 switch 语句中使用表达式，提供更好的类型推断和更灵活的写法。 ZGC 垃圾回收器改进：提高了 ZGC 垃圾回收器的性能和可靠性。 应用程序类数据共享改进：提高了应用程序类数据共享的性能和效率。 Java SE 14 （Java 14） # 2020年3月17日\ninstanceof 模式匹配：允许在 instanceof 操作符中使用模式匹配，提高了代码的简洁性和可读性。 Records 类：提供了一种更简单和安全的数据类的定义方式。 Switch 表达式增强：允许使用箭头操作符(-\u0026gt;)作为 lambda 表达式的简写语法。 文本块增强：允许在文本块中使用嵌入式表达式，使得文本块更加灵活和强大。 改进的 NullPointerException 信息：提供更详细的 NullPointerException 信息。 Java SE 15 （Java 15） # 隐式的类文件：允许在 Java 源代码中定义多个类，而不需要单独的类文件。 改进的文本块：允许在文本块中使用转义字符和 Unicode 转义，提高了文本块的灵活性和可读性。 改进的 switch 表达式：允许在 switch 语句中使用多个匹配项，提供更灵活的写法。 Sealed 类和接口：允许控制哪些类或接口可以继承或实现该类或接口，提高了代码的安全性和可维护性。 其他改进：包括增强的 ZGC 垃圾回收器、改进的内存管理、新增的 Unix 域套接字 API 等。 Java SE 16 （Java 16） # 增强的文本块：允许在文本块中使用转义字符和嵌入式表达式。 移除了废弃的 ParallelScavenge 垃圾回收器。 改进的 ZGC 垃圾回收器：提高了性能和可靠性，增加了可配置参数。 Records 类的增强：允许在 records 类中添加静态方法和私有构造函数。 Vector API：提供了一种新的 API，用于高效地执行矢量化操作。 Java SE 17（Java 17）-LTS长期支持版本 # 嵌套枚举：允许在类和接口中定义嵌套枚举，提高了代码的可读性和简洁性。 改进的 switch 语句：允许在 switch 语句中使用 case 标签作为表达式，提供更灵活的写法。 预览性功能：包括模式匹配、嵌套枚举、记录类的序列化等新特性。 增强的垃圾回收器：提高了性能和可靠性，增加了可配置参数。 其他改进：包括新的内存管理和性能优化，增强的 JIT 编译器等。 Java SE 18（Java 18）[2] # 400：默认使用 UTF-8 408：简易 Web 服务器 413：Java API 文档中的代码片段 416：使用方法句柄重新实现核心反射 417：矢量 API 418：网络地址解析 SPI 419：外部函数和内存 API 420：switch 的模式匹配 421：废弃对象终止机制\nJava SE 19（Java 19） [3] # 405: Record Patterns (Preview) 422: Linux/RISC-V Port 424: Foreign Function \u0026amp; Memory API (Preview) 425: Virtual Threads (Preview) 426: Vector API (Fourth Incubator) 427: Pattern Matching for switch (Third Preview) 428: Structured Concurrency (Incubator)\nJava SE 20（Java 20） [4] # 429: Scoped Values (Incubator) 432: Record Patterns (Second Preview) 433: Pattern Matching for switch (Fourth Preview) 434: Foreign Function \u0026amp; Memory API (Second Preview) 436: Virtual Threads (Second Preview) 437: Structured Concurrency (Second Incubator) 438: Vector API (Fifth Incubator)\nJava SE 21（Java 21） [5] # 430: String Templates (Preview) 431: Sequenced Collections 439: Generational ZGC 440: Record Patterns 441: Pattern Matching for switch 442: Foreign Function \u0026amp; Memory API (Third Preview) 443: Unnamed Patterns and Variables (Preview) 444: Virtual Threads [6][7] 445: Unnamed Classes and Instance Main Methods (Preview) 446: Scoped Values (Preview) 448: Vector API (Sixth Incubator) 449: Deprecate the Windows 32-bit x86 Port for Removal 451: Prepare to Disallow the Dynamic Loading of Agents 452: Key Encapsulation Mechanism API 453: Structured Concurrency (Preview)\n特性 [8] # 文字块 text blocks | JDK 13-JDK 15 # String textBlock = \u0026#34;\u0026#34;\u0026#34; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;\u0026#34;Hello World!\u0026#34;\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026#34;\u0026#34;\u0026#34;; System.out.println( \u0026#34;Here is the text block:\\n\u0026#34; + textBlock); record 档案类 [不可变] | JDK14-JDK16 # public record Circle(double radius) implements Shape { @Override public double area() { return Math.PI * radius * radius; } } sealed classes 封闭类 [扩展性] | JDK 15-JDK 17 # public abstract sealed class Shape permits Circle, Square { public final String id; public Shape(String id) { this.id = id; } public abstract double area(); } 类型匹配 [切除臃肿的强制转换] | JDK 14-JDK 16 # if (shape instanceof Rectangle rect) { return (rect.length == rect.width); } switch 表达式 [简化多情景操作] | JDK 12-JDK 14 # int daysInMonth = switch (month) { case Calendar.JANUARY, Calendar.MARCH, Calendar.MAY, Calendar.JULY, Calendar.AUGUST, Calendar.OCTOBER, Calendar.DECEMBER -\u0026gt; 31; case Calendar.APRIL, Calendar.JUNE, Calendar.SEPTEMBER, Calendar.NOVEMBER -\u0026gt; 30; case Calendar.FEBRUARY -\u0026gt; { if (((year % 4 == 0) \u0026amp;\u0026amp; !(year % 100 == 0)) || (year % 400 == 0)) { yield 29; } else { yield 28; } } default -\u0026gt; throw new RuntimeException( \u0026#34;Calendar in JDK does not work\u0026#34;); }; switch匹配 [适配不同的类型] | JDK 17-21 # public static boolean isSquare(Shape shape) { return switch (shape) { case null, Shape.Circle c -\u0026gt; false; case Shape.Square s -\u0026gt; true; }; } 外部内存接口 | JDK18-? # ByteBuffer \u0026amp;\u0026amp; 零拷贝 使用堆外存储最常用的办法，就是使用 ByteBuffer 这个类来分配直接存储空间（direct buffer）。JVM 虚拟机会尽最大努力直接在直接存储空间上执行 IO 操作，避免数据在本 地和 JVM 之间的拷贝。 由于频繁的内存拷贝是性能的主要障碍之一。所以为了极致的性能，应用程序通常也会尽 量避免内存的拷贝。理想的状况下，一份数据只需要一份内存空间，这就是我们常说的零 拷贝。\n用 ByteBuffer 这个类来分配直接存储空间的方法\npublic static ByteBuffer allocateDirect(int capacity); 第一个缺陷是没有资源释放的接口。 第二个缺陷是存储空间尺寸的限制。\n外部内存接口\ntry (ResourceScope scope = ResourceScope.newConfinedScope()) { MemorySegment segment = MemorySegment.allocateNative(4, scope); for (int i = 0; i \u0026lt; 4; i++) { MemoryAccess.setByteAtOffset(segment, i, (byte)\u0026#39;A\u0026#39;); } } 外部函数接口[取代Java本地接口] | JDK 17-? # public class HelloWorld { public static void main(String[] args) throws Throwable { try (ResourceScope scope = ResourceScope.newConfinedScope()) { CLinker cLinker = CLinker.getInstance(); MemorySegment helloWorld = CLinker.toCString(\u0026#34;Hello, world!\\n\u0026#34;, scope); MethodHandle cPrintf = cLinker.downcallHandle( CLinker.systemLookup().lookup(\u0026#34;printf\u0026#34;).get(), MethodType.methodType(int.class, MemoryAddress.class), FunctionDescriptor.of(CLinker.C_INT, CLinker.C_POINTER)); cPrintf.invoke(helloWorld.address()); } } } GC # G1, ZGC, 分代式 ZGC\n参考 # Java各个版本发布时间和主要特性整理！ Java 历史大版本及其详细特性介绍: Java 18 的新特性 JDK 19 JDK 20 JDK 21 Java19 虚拟线程原理介绍及实现 *** Java虚拟线程：异步编程之死 《深入剖析 Java 新特性》 范学雷 02,03,04,05,06,07,08,09,12, 13 从Java 11升级到Java 17 V 未 "},{"id":3,"href":"/Lang/docs/Golang/golangStudy/","title":"Golang 学习资源","section":"Java","content":"\nGolang # 基础\n极客时间 《Go 并发编程实战课》 鸟窝 *** 极客时间 《Go语言从入门到实战》 好像看过 *** 极客时间 《Go 语言核心 36 讲》 郝林 ** 《Effective Go》 Effective Go 英文 高效的 Go 编程 Effective Go 中文 golang 编程规范 - Effective Go 中文 中文 50 Shades of Go 50 Shades of Go: Traps, Gotchas, and Common Mistakes for New Golang Devs\nGolang 新手可能会踩的 50 个坑 项目\u0026amp;进阶\n极客时间 《Go 语言项目开发实战》 孔令飞@腾讯 *** 极客训练营 《go进阶训练营 第4期》 bili V 毛剑 *** gotalk\ntalkgo @github Mix 0voice/Introduction-to-Golang ***\nGo 源码分析 Go source code analysis(zh-cn) 曹大 滴滴 ***\nbook Go语言圣经中文版 Go语言圣经（中文版） Go语言高级编程(Advanced Go Programming)\nGolang 个人blog # Tony Bai golang大神 *** 鸟窝 Java， golang 微博架构师 *** 罗道文 golang python NSQ 有深度 * 2017 停更 张晓龙 golang * 学习路线 # 学习路线 【上集】2022 年 Go 语言最全学习路线：十分钟带你过思维导图！ 【下集】2022 年 Go 语言最全学习路线：十分钟带你过思维导图！爆肝几天几夜整理的超详细 Go 学习 作者blog GOLANG ROADMAP *** GOLANG ROADMAP\n邀请码：caspar "},{"id":4,"href":"/Lang/docs/Golang/golangSlice/","title":"Golang基础-Slice","section":"Java","content":"\narray和slice # 数组长度是固定的， slice长度是可变的 slice底层实现 [2] # type slice struct { array unsafe.Pointer len int cap int } slice 初始化 [1] # 对于 make 来说，它可以初始化 slice 的 length 和 capacity，如果我们能确定 slice 里面会存放多少元素，从性能的角度考虑最好使用 make 初始化好，因为对于一个空的 slice append 元素进去每次达到阈值都需要进行扩容\nCode Example [1] # 参考 # [长文]从《100 Go Mistakes》我总结了什么？ gExamples slice_test.go 1.Go slice的底层实现原理? "},{"id":5,"href":"/Lang/docs/Java/other/designPatternsInJava/","title":"Java里的设计模式","section":"Other","content":"\n参考 # JDK里的设计模式 Examples of GoF Design Patterns in Java\u0026rsquo;s core libraries Java 设计模式 未 图说设计模式 未 常用开源框架中设计模式使用分析（全） 阿里加多 *** 未 设计模式概览图 *** 未 "},{"id":6,"href":"/Lang/docs/Java/other/optimize/","title":"JVM性能调优","section":"Other","content":"\n参考 # 从实际案例聊聊Java应用的GC优化 录录\n"},{"id":7,"href":"/Lang/docs/Java/core/collection/","title":"Java集合总结","section":"Core","content":"\n参考： # JDK Collection 源代码 关于Java集合的小抄 白衣 限流系统如何发现系统的热点 阿里中间件团队博客 不正当使用HashMap导致cpu 100%的问题追究 王宏江 并发环境下HashMap引起的full gc排查 ol_beta 不止JDK7的HashMap，JDK8的ConcurrentHashMap也会造成CPU 100% 朱小厮 朱忠华 "},{"id":8,"href":"/Lang/docs/Java/core/aop/","title":"AOP总结","section":"Core","content":"\n参考: # 1.AOP技术讨论 乒乓狂魔 2.AOP 那点事儿 黄勇 3.AOP 那点事儿（续集） 黄勇 4.AOP实现机制 fantasy 5.动态代理方案性能对比 javatar 6.Java动态代理机制详解（JDK 和CGLIB，Javassist，ASM） 亦山 7.Spring事务处理时自我调用的解决方案及一些实现方式的风险 张开涛\n"},{"id":9,"href":"/Lang/docs/Java/core/classloaderSummarize/","title":"Classloader总结","section":"Core","content":"\n参考: # 深入浅出ClassLoader 你真的了解ClassLoader吗？ 魏 鹏 class卸载、热替换和Tomcat的热部署的分析 heavensay 《实战Java虚拟机》 第10章 "},{"id":10,"href":"/Lang/docs/Java/core/gc/","title":"垃圾收集GC总结","section":"Core","content":"\n并发标记算法 # CMS： 三色标记算法 + 增量更新（Incremental update） G1： 三色标记算法 + STAB（snapshot-at-the-beginning） Java虚拟机 \u0026mdash;-三色标记与G1垃圾回收器 参考： # 源码分析：Java对象的内存分配 iceAeterna 《深入理解Java虚拟机（第2版）》 第3章 周志明 深入理解GC ——MinorGC\\MajorGC\\FullGC 张硕的博客 触发JVM进行Full GC的情况及应对策略 yexx Netty之有效规避内存泄漏 江南白衣 周期性Full GC的异常排查 weiplex 一个大对象引起的血案，GC的踩坑实录 何锦彬 生产环境下持久带满导致FullGC，如何跟踪 又是一个程序员粗心的代码引起频繁FullGC的案例 微信公众号里的 JVM初探- 使用堆外内存减少Full GC 菜鸟-翡青 我遇到tomcat 7 full gc频繁的问题 auzll 一次堆外OOM问题的排查过程 谢照东 占小狼的博客 美团三面：一个线程OOM，进程里其他线程还能运行么？ 孤独烟 Java技术驿站 netty 堆外内存泄露排查盛宴 闪电侠的博客 netty的bug 线上故障排查(2) - Java应用故障之堆溢出OOM问题及排查方案 冯立彬 未 "},{"id":11,"href":"/Lang/docs/Java/concurrent/threadNum/","title":"线程池最佳线程数","section":"并发","content":"\n最佳实践: 曾经遇到过任务被丢给线程池之后，长时间都没有被执行的诡异问题。最初，我认为这是代码的 Bug 导致的，后来经过排查发现，是因为线程池的coreThreadCount 和 maxThreadCount 设置的比较小，导致任务在线程池里面大量的堆积，在调大了这两个参数之后问题就解决了.\n参考: # 工作线程数究竟要设置为多少 架构师之路 蚂蚁金服技术专家总结：性能优化的常见招式 jurassic_1 《Java 并发编程实践》 8.2定制线程池的大小 Brian Goetz 高并发系统设计40问 - 07 | 池化技术：如何减少频繁创建数据库连接的性能损耗？ 唐扬 ​\n"},{"id":12,"href":"/Lang/docs/Java/concurrent/volatile-CAS/","title":"多线程中的volatile和CAS","section":"并发","content":"\n参考: # Java 理论与实践: 正确使用 Volatile 变量 从volatile解读ConcurrentHashMap（jdk1.6.0）无锁读 为什么volatile不能保证原子性而Atomic可以 阿里巴巴Java开发手册 非阻塞同步算法与CAS(Compare and Swap)无锁算法 非阻塞算法在并发容器中的实现 程晓明 "},{"id":13,"href":"/Lang/docs/Java/concurrent/lock/","title":"多线程中的锁","section":"并发","content":"\n参考 # 《java并发编程实践》 13章 显示锁 ,13.5 读-写锁 轻松学习java可重入锁(ReentrantLock)的实现原理 锁模式 -\u0026gt; 共享锁，排他锁 轻松掌握java读写锁(ReentrantReadWriteLock)的实现原理 Java中的读/写锁 作者:Jakob Jenkov Java同步块 作者:Jakob Jenkov 《Java并发编程的艺术》-Java并发包中的读写锁及其实现分析 怎么理解Condition 码梦为生|刘锟洋 多线程之：偏向锁，轻量级锁，重量级锁 无信不立 "},{"id":14,"href":"/Lang/docs/Java/concurrent/thread/","title":"Java多线程总结","section":"并发","content":"\n参考： # 非阻塞同步算法与CAS(Compare and Swap)无锁算法 高性能队列——Disruptor java多线程体系 东隼 《并发编程实践》 Brian Goetz 第3章 Java并发之AQS详解 waterystone 面试官：线程顺序执行,这么多答案你都答不上来？ Join, wait, Condition, 线程池 "},{"id":15,"href":"/Lang/docs/Java/concurrent/cancelAndShutdown/","title":"Java多线程中的取消和关闭","section":"并发","content":"\n取消和关闭 基础 中断状态 中断请求 取消点 任务取消 取消策略（how/when/what） how/when volatile的取消状态+非阻塞方法(正确) volatile的取消状态+阻塞方法(错误) 中断的状态显示的检查（正确）.Thread.currentThread().isInterrupted() what, 中断策略（如何响应中断请求） InterruptedException传递给调用者，捕获后恢复中断的状态，Thread.currentThread().interrupted(). 封装成shutdown方法 通过Future.cancel来取消任务 中断当前线程 阻塞函数 抛出InterruptedException Thread.isInterrupted()返回false eg. Object的wait(),Thread的join(),sleep() IO上的阻塞 BIO Socket读写网络 JDBC驱动MySQL-connector-java nio InterruptibleChannel InterruptibleChannel将被关闭 抛出ClosedByInterruptException Thread.isInterrupted()返回true Selector Selector#select()方法将立即返回 不会抛出异常 Thread.isInterrupted()返回true 服务取消 生命周期方法 start() stop() ExceuteService.shutDown()/shutDownNow() 致命药丸(akka的Poison Pill) 锁中断 不可中断 内部锁synchronized, ReentrantLock.lock() 可中断 显示锁ReentrantLock.tryLock()，.lockInterruptibly() "},{"id":16,"href":"/Lang/docs/Java/core/javaMemoryLeak/","title":"Java内存泄漏的案例和解决方案","section":"Core","content":"\n如果一个可达对象的生命周期很长，它有一个生命周期较短的对象引用，此时就可能出现Java内存泄漏。也即是说， 造成内存泄漏的原因是对象虽然可达但不是活动的。\n避免内存泄漏的三种方式 # 1. 软引用 # 对于缓存，如果没有合适的策略让老的缓存项目到期就可能遇到内存泄漏。\n我们希望缓存能用上所有的可用内存，只是在需要额外资源的时候才释放资源。 通过软可达可以实现资源的释放。\n释放软可达对象的规则：\nI. gc抛出OOM异常之前要尝试释放软引用\nII. gc以LRU的顺序释放软引用\n举例：\nGoogle LoadingCache中的CacheBuilder.softValues()\n2. 弱引用 # 弱引用可以用于协助垃圾回收， 这是通用的解决方案。\n举例： threadLocal\n每个线程中有一个Map, 这个Map的类型是ThreadLocal.ThreadLocalMap. Map中的key为一个threadlocal实例. 这个Map的key使用了弱引用。 每个key都弱引用指向threadlocal. 当把threadlocal实例置为null以后,没有任何强引用指向threadlocal实例,所以threadlocal将会被gc回收.\nps: value却不能回收,因为存在一条从current thread连接过来的强引用. 只有当前thread结束以后, current thread就不会存在栈中,强引用断开, Current Thread, Map, value将全部被GC回收. 如果使用线程池，线程的强引用会长时间的存在，为了防止内存泄漏，最好的做法是将调用threadlocal的remove方法。\n3. 打开(增加)和关闭（删除）方法成对出现 # 资源申请和回收不成对会使资源没释放，造成内存泄漏。\n举例：\nI. 在finally块中关闭打开的资源和异常处理。\nII. 使用try-with-resources语句（Java SE7新特性）\ntry (BufferedReader br = new BufferedReader(new FileReader(path))) {\rreturn br.readLine();\r} 内存泄漏案例 # \u0026laquo;实战Java虚拟机——JVM故障诊断与性能优化\u0026raquo; 7.2.2节中有关JDK6.0里String.substring()可能引发的内存泄漏\n\u0026laquo; Effective.Java.中文版 - 第二版\u0026raquo; - 第六条 消除过期的对象引用 如果一个类自己管理内存，程序员就要警惕内存泄漏问题。\n大量static字段引起的内存泄漏\n不正确的equals()和hashCode()实现\n常量字符串造成的内存泄漏\n参考 # 1 . 了解Java中的内存泄漏 作者:baeldung 译者:thornhill\n"},{"id":17,"href":"/Lang/docs/Java/core/javaString/","title":"Java 字符串","section":"Core","content":"\n"},{"id":18,"href":"/Lang/docs/Java/core/javaMemoryModel/","title":"Java内存模型","section":"Core","content":"\n参考: # JVM内部原理 原文作者：James D Bloom 翻译：梅小西 浅谈HotSpot逃逸分析 占小狼 class卸载、热替换和Tomcat的热部署的分析 heavensay java自定义classloader引发的思考 editice 《深入理解java虚拟机》 第二章 周志明 浅谈Java String内幕 占小狼 JMM和底层实现原理 王侦 *** 未 "},{"id":19,"href":"/Lang/docs/Java/concurrent/concurrentCollection/","title":"Java并发容器总结","section":"并发","content":"\n参考: # 关于Java集合的小抄 白衣 谈谈ConcurrentHashMap1.7和1.8的不同实现 占小狼 高性能队列——Disruptor 非阻塞算法在并发容器中的实现 程晓明 从volatile解读ConcurrentHashMap（jdk1.6.0）无锁读 绫萱 JAVA并发容器代码随读 BucketLi 聊聊并发（四）深入分析ConcurrentHashMap 方 腾飞 Java8 新特性之流式数据处理 深蓝至尊 不止JDK7的HashMap，JDK8的ConcurrentHashMap也会造成CPU 100% 朱小厮 朱忠华 "}]